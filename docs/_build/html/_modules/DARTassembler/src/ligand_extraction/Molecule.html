<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DARTassembler.src.ligand_extraction.Molecule &#8212; DART  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for DARTassembler.src.ligand_extraction.Molecule</h1><div class="highlight"><pre>
<span></span><span class="c1"># standard Python packages</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">pysmiles</span>

<span class="c1"># some special functions which are required</span>
<span class="kn">from</span> <span class="nn">DARTassembler.src.ligand_extraction.composition</span> <span class="kn">import</span> <span class="n">Composition</span>
<span class="kn">from</span> <span class="nn">ase.visualize</span> <span class="kn">import</span> <span class="n">view</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Point3D</span><span class="p">,</span> <span class="n">Plane</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>


<span class="c1"># collection of molecule objects of other packages</span>
<span class="kn">from</span> <span class="nn">ase</span> <span class="kn">import</span> <span class="n">io</span><span class="p">,</span> <span class="n">Atoms</span>
<span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>
<span class="kn">from</span> <span class="nn">pysmiles</span> <span class="kn">import</span> <span class="n">read_smiles</span>

<span class="kn">from</span> <span class="nn">DARTassembler.src.constants.Periodic_Table</span> <span class="kn">import</span> <span class="n">DART_Element</span>
<span class="kn">from</span> <span class="nn">DARTassembler.src.constants.constants</span> <span class="kn">import</span> <span class="n">metals_in_pse</span>
<span class="kn">from</span> <span class="nn">DARTassembler.src.ligand_extraction.bond_orders</span> <span class="kn">import</span> <span class="n">graph_to_smiles</span>
<span class="c1"># importing own scripts</span>
<span class="kn">from</span> <span class="nn">DARTassembler.src.ligand_extraction.utilities_graph</span> <span class="kn">import</span> <span class="n">graph_from_graph_dict</span><span class="p">,</span> <span class="n">graph_to_dict_with_node_labels</span><span class="p">,</span> <span class="n">view_graph</span><span class="p">,</span> <span class="n">graphs_are_equal</span><span class="p">,</span> \
    <span class="n">unify_graph</span><span class="p">,</span> <span class="n">get_sorted_atoms_and_indices_from_graph</span><span class="p">,</span> <span class="n">get_reindexed_graph</span><span class="p">,</span> <span class="n">find_node_in_graph_by_label</span><span class="p">,</span> \
    <span class="n">get_graph_fragments</span><span class="p">,</span> <span class="n">count_atoms_with_n_bonds</span><span class="p">,</span> <span class="n">get_graph_hash</span><span class="p">,</span> <span class="n">get_heavy_atoms_graph</span><span class="p">,</span> \
    <span class="n">get_only_complex_graph_connected_to_metal</span><span class="p">,</span> <span class="n">get_adjacency_matrix</span><span class="p">,</span> <span class="n">assert_graph_and_coordinates_are_consistent</span><span class="p">,</span> \
    <span class="n">remove_node_features_from_graph</span><span class="p">,</span> <span class="n">make_multigraph_to_graph</span>
<span class="kn">from</span> <span class="nn">DARTassembler.src.ligand_extraction.utilities</span> <span class="kn">import</span> <span class="n">identify_metal_in_ase_mol</span><span class="p">,</span> <span class="n">make_None_to_NaN</span><span class="p">,</span> <span class="n">update_dict_with_warning_inplace</span><span class="p">,</span> <span class="n">is_between</span>
<span class="kn">from</span> <span class="nn">DARTassembler.src.ligand_extraction.utilities_Molecule</span> <span class="kn">import</span> <span class="n">get_standardized_stoichiometry_from_atoms_list</span><span class="p">,</span> \
    <span class="n">unknown_rdkit_bond_orders</span><span class="p">,</span> <span class="n">calculate_angular_deviation_of_bond_axis_from_ligand_center</span><span class="p">,</span> \
    <span class="n">find_smallest_ring_with_specified_nodes</span><span class="p">,</span> <span class="n">get_max_deviation_from_coplanarity</span><span class="p">,</span> <span class="n">if_same_stoichiometries</span>
<span class="kn">from</span> <span class="nn">DARTassembler.src.assembly.stk_utils</span> <span class="kn">import</span> <span class="n">RCA_Mol_to_stkBB</span><span class="p">,</span> <span class="n">convert_RCA_to_stk_Molecule</span>

<span class="k">class</span> <span class="nc">RCA_Molecule</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The idea of this class is to build a method which contains an ase molecule for visualization but also other convenient features, as a graph representation and all the global information we have at hand when creating a database</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">:</span> <span class="n">Atoms</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atomic_props</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">global_props</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">graph_creating_strategy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># do not specify &#39;default&#39; as default, because then there would be no warning when making the graphs</span>
                 <span class="n">has_ligands</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">reindex_graph</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">warnings</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>
                 <span class="n">other_props</span><span class="p">:</span> <span class="nb">dict</span><span class="o">=</span><span class="p">{},</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param graph_creating_strategy: If we dont give a graph we might want to specify the graph creating strategy</span>
<span class="sd">        :param kwargs: additional parameters which are specified for the graph creation, such as</span>
<span class="sd">            skin: float</span>
<span class="sd">            cutoff_corrections_for_metals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warnings</span> <span class="o">=</span> <span class="n">warnings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_label</span> <span class="o">=</span> <span class="s1">&#39;node_label&#39;</span>  <span class="c1"># node label specifying the atom type</span>

        <span class="k">if</span> <span class="n">atomic_props</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atomic_props</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">global_props</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">global_props</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span> <span class="o">=</span> <span class="n">atomic_props</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_props</span> <span class="o">=</span> <span class="n">global_props</span>

        <span class="c1"># todo: refactor so that `comment` is not in the atomic_props anymore but in the global_props</span>
        <span class="k">if</span> <span class="s1">&#39;comment&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">[</span><span class="s1">&#39;comment&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;comment&#39;</span><span class="p">])</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;comment&#39;</span><span class="p">]</span>

        <span class="c1"># Generate mol from atomic_props if possible and no mol given yet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mol_from_input</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_hydrogens</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">atom</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_protons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_protons</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">has_ligands</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># if we expect ligands, we can set up an empty ligand list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ligands</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we pass over all the kwargs, the respective functions will only grab those they need</span>
            <span class="c1"># but no kwarg is mandatory as all have default values set</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_graph</span><span class="p">(</span><span class="n">graph_creating_strategy</span><span class="o">=</span><span class="n">graph_creating_strategy</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span>
                                         <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reindex_graph</span><span class="p">:</span>
                <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reindexed_graph</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph_hash</span><span class="p">()</span>

        <span class="c1"># Set kwargs so that they become properties of the molecule</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_other_props_as_properties</span><span class="p">(</span><span class="n">other_props</span><span class="o">=</span><span class="n">other_props</span><span class="p">)</span>

        <span class="c1"># Bond and bond order attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_bonds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;has_bond_order_attribute&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_bond_order_attribute</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_for_bond_order_attribute</span><span class="p">()</span>     <span class="c1"># has bond order attribute for all bonds, but some bonds are marked as unknown</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;has_unknown_bond_orders&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_unknown_bond_orders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_for_unknown_bond_orders</span><span class="p">()</span>       <span class="c1"># at least one of the bond orders is unknown</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;has_good_bond_orders&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_good_bond_orders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_for_good_bond_orders</span><span class="p">()</span>             <span class="c1"># has bond orders and all are known</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">validity_check_created_molecule</span><span class="p">()</span>

        <span class="c1"># Different graph hashes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;heavy_atoms_graph_hash&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">heavy_atoms_graph_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_heavy_atoms_graph_hash</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;bond_order_graph_hash&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bond_order_graph_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bond_order_graph_hash</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hash</span><span class="p">()</span>

        <span class="c1"># Set additional properties</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;stoichiometry&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_standardized_stoichiometry</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_additional_molecule_information_to_global_props</span><span class="p">()</span>




        <span class="c1"># outcommented for now because not really needed and maybe computationally expensive</span>
        <span class="c1"># if self.check_for_good_bond_orders():</span>
        <span class="c1">#     self.smiles = self.get_smiles()</span>
        <span class="c1"># else:</span>
        <span class="c1">#     self.smiles = None</span>

        <span class="c1"># outcommented for now because memory intensive</span>
        <span class="c1"># if self.check_for_bond_order_attribute():</span>
        <span class="c1">#     self.n_unknown_bond_orders = self.count_unknown_bond_orders()</span>
        <span class="c1">#     for _, _, edge in self.graph.edges(data=True):</span>
        <span class="c1">#         edge[&#39;bond_order_pysmiles&#39;] = bond_order_rdkit_to_pysmiles[edge[&#39;bond_type&#39;]]</span>
        <span class="c1"># else:</span>
        <span class="c1">#     self.n_unknown_bond_orders = None</span>

    <span class="k">def</span> <span class="nf">validity_check_created_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method aims to check if the created molecule is valid,</span>
<span class="sd">        i.e. if all its attributes are compatible</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Graph check (only really needed if we create the graphs by an external input</span>
        <span class="c1"># assures that the graph corresponds to the atomic properties and that the order is the same</span>
        <span class="c1"># which is crucial for the extraction process</span>
        <span class="n">atoms</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_sorted_atoms_and_indices_from_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>

        <span class="n">both_atom_lists_printed</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">graph atoms: </span><span class="si">{</span><span class="n">atoms</span><span class="si">}</span><span class="se">\n</span><span class="s1">atomic_props[&quot;atoms&quot;]: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">same_atoms_contained</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">same_atoms_contained</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;The atoms from the graph and the atoms from the atomic_props don</span><span class="se">\&#39;</span><span class="s1">t match:</span><span class="si">{</span><span class="n">both_atom_lists_printed</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">same_order_of_atoms</span> <span class="o">=</span> <span class="n">atoms</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">same_order_of_atoms</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Order of atoms in graph and in atomic_props doesn</span><span class="se">\&#39;</span><span class="s1">t match:</span><span class="si">{</span><span class="n">both_atom_lists_printed</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="nf">add_warning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">warning</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">warning</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">if_same_stoichiometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_stoi</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the stoichiometry of the molecule is the same as the given stoichiometry.</span>
<span class="sd">        :param other_stoi: stoichiometry to compare to</span>
<span class="sd">        :return: True if the stoichiometry is the same, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">if_same_stoichiometries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stoichiometry</span><span class="p">,</span> <span class="n">other_stoi</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_reindexed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_label</span><span class="o">=</span><span class="s1">&#39;node_label&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reindex and sort the graph nodes from 0 to n-1 to match the atom order in the atomic_props. Also make a lot of checks to make sure everything is consistent.</span>
<span class="sd">        :return: reindexed graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reindexed_graph</span> <span class="o">=</span> <span class="n">get_reindexed_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">ligand_to_metal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># Molecule is not a ligand</span>
            <span class="n">ligand_to_metal</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">assert_graph_and_coordinates_are_consistent</span><span class="p">(</span>
                                                    <span class="n">graph</span><span class="o">=</span><span class="n">reindexed_graph</span><span class="p">,</span>
                                                    <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">],</span>
                                                    <span class="n">graph_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_hash</span><span class="p">,</span>
                                                    <span class="n">ligand_to_metal</span><span class="o">=</span><span class="n">ligand_to_metal</span><span class="p">,</span>
                                                    <span class="n">node_label</span><span class="o">=</span><span class="n">node_label</span>
                                                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">reindexed_graph</span>

    <span class="k">def</span> <span class="nf">check_if_graph_and_coordinates_are_consistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_label</span><span class="o">=</span><span class="s1">&#39;node_label&#39;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ligand_to_metal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># Molecule is not a ligand</span>
            <span class="n">ligand_to_metal</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">assert_graph_and_coordinates_are_consistent</span><span class="p">(</span>
                                                        <span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span>
                                                        <span class="n">graph_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_hash</span><span class="p">,</span>
                                                        <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">],</span>
                                                        <span class="n">ligand_to_metal</span><span class="o">=</span><span class="n">ligand_to_metal</span><span class="p">,</span>
                                                        <span class="n">node_label</span><span class="o">=</span><span class="n">node_label</span>
                                                    <span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">get_mol_from_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coord_list_3D</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="n">key_</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">key_</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span>
                             <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])]</span>
            <span class="n">atom_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">coord_list_3D</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mol</span>

    <span class="k">def</span> <span class="nf">get_ase_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove_elements</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[],</span> <span class="n">add_atoms</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[])</span> <span class="o">-&gt;</span> <span class="n">Atoms</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get ASE molecule from atomic properties.</span>
<span class="sd">        :param remove_elements: list of elements to remove from the molecule</span>
<span class="sd">        :param add_atoms: list of tuples of the form [(element, (x,y,z))] to add to the returned ase molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check input add_atoms:</span>
        <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">add_atoms</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Coordinates for element </span><span class="si">{</span><span class="n">el</span><span class="si">}</span><span class="s2"> are not of length 3: </span><span class="si">{</span><span class="n">coords</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Element </span><span class="si">{</span><span class="n">el</span><span class="si">}</span><span class="s2"> is not a string&quot;</span>

        <span class="n">coord_list_3D</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="n">key_</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">key_</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span>
                         <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])]</span>
        <span class="n">atom_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]</span>

        <span class="c1"># Remove specified elements</span>
        <span class="k">if</span> <span class="n">remove_elements</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="n">coord_list_3D</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">remove_elements</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">coord_list_3D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Add specified elements</span>
        <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">add_atoms</span><span class="p">:</span>
            <span class="n">atom_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
            <span class="n">coord_list_3D</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="n">mol</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">coord_list_3D</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mol</span>

    <span class="k">def</span> <span class="nf">set_other_props_as_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_props</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">prop</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other_props</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">differing_prop_already_exists</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">prop</span><span class="p">)</span> <span class="o">!=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">differing_prop_already_exists</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Property </span><span class="si">{</span><span class="n">prop</span><span class="si">}</span><span class="s1"> already exists and is different.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">add_additional_molecule_information_to_global_props</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n_elements</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">])))</span>
        <span class="n">mol_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">get_masses</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n_C_H_bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_C_H_bonds</span><span class="p">()</span>
        <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;n_atoms&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span>
                    <span class="s1">&#39;n_elements&#39;</span><span class="p">:</span> <span class="n">n_elements</span><span class="p">,</span>
                    <span class="s1">&#39;molecular_weight&#39;</span><span class="p">:</span> <span class="n">mol_weight</span><span class="p">,</span>
                    <span class="s1">&#39;n_C_H_bonds&#39;</span><span class="p">:</span> <span class="n">n_C_H_bonds</span>
                    <span class="p">}</span>

        <span class="n">update_dict_with_warning_inplace</span><span class="p">(</span>
                                            <span class="n">dict_to_update</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">,</span>
                                            <span class="n">dict_with_information</span><span class="o">=</span><span class="n">info</span>
                                        <span class="p">)</span>

        <span class="k">return</span> <span class="n">info</span>

    <span class="k">def</span> <span class="nf">get_smiles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the SMILES string of the molecule.</span>
<span class="sd">        @return: SMILES string of the molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">smiles</span> <span class="o">=</span> <span class="n">graph_to_smiles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">element_label</span><span class="o">=</span><span class="s1">&#39;node_label&#39;</span><span class="p">,</span> <span class="n">bond_label</span><span class="o">=</span><span class="s1">&#39;bond_type&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">smiles</span>

    <span class="k">def</span> <span class="nf">count_C_H_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_label</span><span class="o">=</span><span class="s1">&#39;node_label&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of C-H bonds in the molecule.</span>
<span class="sd">        @return: number of C-H bonds in the molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_bonds</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="n">el1</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">idx1</span><span class="p">][</span><span class="n">node_label</span><span class="p">]</span>
            <span class="n">el2</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">idx2</span><span class="p">][</span><span class="n">node_label</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">el1</span><span class="p">,</span> <span class="n">el2</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">]:</span>
                <span class="n">n_bonds</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">n_bonds</span>

    <span class="k">def</span> <span class="nf">get_n_protons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n_protons</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">DART_Element</span><span class="p">(</span><span class="n">el</span><span class="p">)</span><span class="o">.</span><span class="n">atomic_number</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">n_protons</span>

    <span class="k">def</span> <span class="nf">has_bond_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond_types</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">bond_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;bond_type&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the molecular graph has any of the specified bond types.</span>
<span class="sd">        @param bond_types: list of integers of rdkit bond types</span>
<span class="sd">        @return: True if the molecular graph has any of the specified bond types, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_for_bond_order_attribute</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">bond_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">bond_type</span> <span class="o">=</span> <span class="n">bond_dict</span><span class="p">[</span><span class="n">bond_type_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bond_type</span> <span class="ow">in</span> <span class="n">bond_types</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">count_bond_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond_types</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">bond_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;bond_type&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts the number of specified bond types in the molecular graph.</span>
<span class="sd">        @param bond_types: list of integers of rdkit bond types</span>
<span class="sd">        @return: True if the molecular graph has any of the specified bond types, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_for_bond_order_attribute</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">bond_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">bond_type</span> <span class="o">=</span> <span class="n">bond_dict</span><span class="p">[</span><span class="n">bond_type_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bond_type</span> <span class="ow">in</span> <span class="n">bond_types</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">check_for_bond_order_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond_label</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span> <span class="s1">&#39;bond_type&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the graph has bond orders for all bonds. Note, these bond orders can be unknown to rdkit and therefore be not useful. If you want to test just for good bond orders, use `self.check_for_good_bond_orders()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Do not compute again if already computed</span>
            <span class="n">contains_bond_orders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bond_order_attribute</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">bond_orders_present</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond_label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">]</span>
            <span class="n">contains_bond_orders</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">bond_orders_present</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">contains_bond_orders</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">bond_orders_present</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Not all bonds in the molecule have bond orders. Some bonds have bond orders, some do not. Return False in check `self.check_for_bond_order_attribute()`.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">contains_bond_orders</span>

    <span class="k">def</span> <span class="nf">check_for_unknown_bond_orders</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the molecular graph has any bond orders that cannot be understood by smiles.</span>
<span class="sd">        @return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Do not compute again if already computed</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_unknown_bond_orders</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_for_bond_order_attribute</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bond_type</span><span class="p">(</span><span class="n">unknown_rdkit_bond_orders</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">count_unknown_bond_orders</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts the number of bond orders which are specified as unknown.</span>
<span class="sd">        @return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_for_bond_order_attribute</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_bond_types</span><span class="p">(</span><span class="n">unknown_rdkit_bond_orders</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">check_for_good_bond_orders</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the molecular graph has any bond orders that cannot be understood by smiles.</span>
<span class="sd">        @return: True if the molecular graph has any bond orders that cannot be understood by smiles, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">good_bond_orders_present</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_good_bond_orders</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">good_bond_orders_present</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_for_bond_order_attribute</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_for_unknown_bond_orders</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">good_bond_orders_present</span>



    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">make_from_atomic_properties</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                                    <span class="n">atomic_props_mol</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                                    <span class="n">global_props_mol</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                                    <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">graph_creating_strategy</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;default&quot;</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwargs</span>
                                    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A more convenient creation method, as in general the atomic properties already imply the information for</span>
<span class="sd">        the ase mol</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">coord_list_3D</span> <span class="o">=</span> <span class="p">[[</span><span class="n">atomic_props_mol</span><span class="p">[</span><span class="n">key_</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">key_</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span>
                         <span class="nb">enumerate</span><span class="p">(</span><span class="n">atomic_props_mol</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])]</span>
        <span class="n">atom_list</span> <span class="o">=</span> <span class="n">atomic_props_mol</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">mol</span><span class="o">=</span><span class="n">Atoms</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">coord_list_3D</span><span class="p">),</span>
                   <span class="n">atomic_props</span><span class="o">=</span><span class="n">atomic_props_mol</span><span class="p">,</span>
                   <span class="n">global_props</span><span class="o">=</span><span class="n">global_props_mol</span><span class="p">,</span>
                   <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
                   <span class="n">graph_creating_strategy</span><span class="o">=</span><span class="n">graph_creating_strategy</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span>
                   <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_graph_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_label</span><span class="o">=</span><span class="s1">&#39;node_label&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of the fragment indices (unconnected components) and their elements of the molecular graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices_fragments</span><span class="p">,</span> <span class="n">element_fragments</span> <span class="o">=</span> <span class="n">get_graph_fragments</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">atom_label</span><span class="o">=</span><span class="n">atom_label</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">indices_fragments</span><span class="p">,</span> <span class="n">element_fragments</span>

    <span class="k">def</span> <span class="nf">get_atomic_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomic_indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the atomic positions of the atoms with the given indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">atomic_indices</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">positions</span>

    <span class="c1"># basic view 3D function</span>
    <span class="k">def</span> <span class="nf">view_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        easy employment of the ase functionality</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>

    <span class="c1"># Graph stuff</span>
    <span class="k">def</span> <span class="nf">make_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph_creating_strategy</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method also allows to overwrite graphs via the command</span>
<span class="sd">        self.graph = self.make_graph(...)</span>
<span class="sd">        which will set self.graph to the newly created graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">DARTassembler.src.ligand_extraction.GraphCreation</span> <span class="kn">import</span> <span class="n">GraphCreation</span>

        <span class="k">return</span> <span class="n">GraphCreation</span><span class="p">(</span>
            <span class="n">graph_creating_strategy</span><span class="o">=</span><span class="n">graph_creating_strategy</span><span class="p">,</span>
            <span class="n">molecule</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span>
            <span class="n">atomic_props</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span><span class="o">.</span><span class="n">G</span>

    <span class="k">def</span> <span class="nf">view_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_label</span><span class="o">=</span><span class="s1">&#39;node_label&#39;</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        simple plot of the molecule as a graph, only connectivity, no distances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">view_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">node_label</span><span class="o">=</span><span class="n">node_label</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">)</span>

    <span class="c1"># Now the hashing</span>
    <span class="k">def</span> <span class="nf">has_graph_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_hash</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">has_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_hash</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_hash</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span>

    <span class="k">def</span> <span class="nf">get_graph_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_hash</span> <span class="o">=</span> <span class="n">get_graph_hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_hash</span>

    <span class="k">def</span> <span class="nf">get_bond_order_graph_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element_label</span><span class="o">=</span><span class="s1">&#39;node_label&#39;</span><span class="p">,</span> <span class="n">bond_label</span><span class="o">=</span><span class="s1">&#39;bond_type&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_for_good_bond_orders</span><span class="p">():</span>
            <span class="n">graph_hash</span> <span class="o">=</span> <span class="n">get_graph_hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="n">element_label</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="n">bond_label</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">graph_hash</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">graph_hash</span>

    <span class="k">def</span> <span class="nf">get_heavy_atoms_graph_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element_label</span><span class="o">=</span><span class="s1">&#39;node_label&#39;</span><span class="p">):</span>

        <span class="n">heavy_graph</span> <span class="o">=</span> <span class="n">get_heavy_atoms_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">element_label</span><span class="o">=</span><span class="n">element_label</span><span class="p">)</span>
        <span class="n">graph_hash</span> <span class="o">=</span> <span class="n">get_graph_hash</span><span class="p">(</span><span class="n">heavy_graph</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">graph_hash</span>

    <span class="k">def</span> <span class="nf">get_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_graph_hash</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_graph_hash</span><span class="p">()</span>

        <span class="c1"># this hash is not randomized, unlike pythons inbuilt hash()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_hash</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;strict&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span>

    <span class="k">def</span> <span class="nf">get_standardized_stoichiometry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a string with the stoichiometry in a standardized way. We use the Hill notation, except that for elements with stoichiometry 1 this 1 is written as well.</span>
<span class="sd">        :return: stoichiometry (str)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">formula</span> <span class="o">=</span> <span class="n">get_standardized_stoichiometry_from_atoms_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_elements_list</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">formula</span>


    <span class="k">def</span> <span class="nf">get_elements_list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of the elements in the molecule.</span>
<span class="sd">        :return: list of elements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">calculate_planarity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the planarity of the molecule.</span>
<span class="sd">        @return: Planarity of the molecule as a float between 0 and 1. 0 means not planar at all (a sphere), 1 means perfectly planar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates_list</span><span class="p">()</span>
        <span class="n">deviation</span> <span class="o">=</span> <span class="n">get_max_deviation_from_coplanarity</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">coordinates</span><span class="p">)</span>  <span class="c1"># deviation is a float that is 0 if the molecule is perfectly planar and &gt; 0 if it is not. The higher the value, the less planar the molecule is.</span>
        <span class="n">planarity</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span> <span class="n">deviation</span><span class="p">)</span>   <span class="c1"># planarity is a float between 0 and 1. 0 means not planar at all (a sphere), 1 means perfectly planar.</span>

        <span class="k">return</span> <span class="n">planarity</span>

    <span class="k">def</span> <span class="nf">get_coordinates_list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinates of the ligand without the metal.</span>
<span class="sd">        @return: Coordinates of the ligand without the metal in format [[x1, y1, z1], [x2, y2, z2], ...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]))]</span>

        <span class="k">return</span> <span class="n">coords</span>

    <span class="k">def</span> <span class="nf">get_atomic_distances_between_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_elements</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span><span class="o">=</span><span class="p">[])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the minimum, maximum and all distances between two atoms in the molecule.</span>
<span class="sd">        @param skip_elements: Do not include bonds with these elements in the calculation</span>
<span class="sd">        @return: tuple of (minimum, maximum, all) distance of atoms in Angstrom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">skip_elements</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">skip_elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">skip_elements</span><span class="p">]</span>

        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="ow">not</span> <span class="p">(</span><span class="n">el</span> <span class="ow">in</span> <span class="n">skip_elements</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">])</span>

        <span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">get_all_distances</span><span class="p">()</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">valid</span><span class="p">,:][:,</span><span class="n">valid</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distances</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">max_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distances</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">max_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="n">min_dist</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">,</span> <span class="n">distances</span>

    <span class="k">def</span> <span class="nf">get_all_inter_atomic_distances_as_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distances between all atoms in the molecule.</span>
<span class="sd">        @return: list of distances between all atoms in the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_atomic_distances_between_atoms</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">unique_distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)):</span>
                <span class="n">unique_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">unique_distances</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometry</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">stoichiometry</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">graphs_are_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="c1"># Finally we want to be able to turn our complex into an .xyz file</span>
    <span class="k">def</span> <span class="nf">get_xyz_file_format_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comment</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns a string that can be written into an .xyz file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">str_</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">str_</span> <span class="o">+=</span> <span class="n">comment</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]):</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">str_</span>

    <span class="k">def</span> <span class="nf">get_xyz_as_array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns a numpy array of the xyz coordinates. Shape: (n_atoms, 3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="nf">print_to_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.xyz&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No valid filename&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">NameError</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_xyz_file_format_string</span><span class="p">())</span>

    <span class="c1"># helper method for the de-assembly</span>
    <span class="k">def</span> <span class="nf">ligand_naming</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">denticity</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ligand_list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>

        <span class="k">if</span> <span class="s2">&quot;CSD_code&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">lig_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;CSD-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">[</span><span class="s2">&quot;CSD_code&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">csd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">[</span><span class="s2">&quot;CSD_code&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lig_key</span> <span class="o">=</span> <span class="s2">&quot;NoCSD&quot;</span>
            <span class="n">csd</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="kn">from</span> <span class="nn">DARTassembler.src.constants.constants</span> <span class="kn">import</span> <span class="n">mini_alphabet</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ligand_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">lig_key</span><span class="si">}</span><span class="s1">-0</span><span class="si">{</span><span class="n">denticity</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">mini_alphabet</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="n">ligand_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">lig</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">lig</span> <span class="ow">in</span> <span class="n">ligand_list</span><span class="p">]:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">ligand_name</span><span class="p">,</span> <span class="n">csd</span>

    <span class="k">def</span> <span class="nf">check_input_inherit_global_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inherit_global_properties</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether `inherit_global_properties` has correct input format.</span>
<span class="sd">        :param inherit_global_properties: input</span>
<span class="sd">        :return: correctly specified inherit_global_properties</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inherit_global_properties</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inherit_global_properties</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unknown_global_property</span> <span class="o">=</span> <span class="p">[</span><span class="n">prop</span> <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">inherit_global_properties</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">prop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">unknown_global_property</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Unknown values </span><span class="si">{</span><span class="n">unknown_global_property</span><span class="si">}</span><span class="s1">. All properties in inherit_global_properties must be found in self.global_properties.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inherit_global_properties</span>

    <span class="k">def</span> <span class="nf">remove_node_features_from_molecular_graphs_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all node features from all molecular graphs in the db except the node features specified in keep.</span>
<span class="sd">        :param keep: list of node features which will not be removed</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">keep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_label</span><span class="p">]</span>

        <span class="n">remove_node_features_from_graph</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">normalize_multigraph_into_graph_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If self.graph is a MultiGraph, it is normalized into a Graph.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">make_multigraph_to_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">write_to_mol_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Graph hash not that important for molecules I guess</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;atomic_props&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">,</span>
            <span class="s2">&quot;global_props&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">,</span>
            <span class="s2">&quot;graph_dict&quot;</span><span class="p">:</span> <span class="n">graph_to_dict_with_node_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">),</span>
            <span class="c1"># &quot;graph_hash&quot;: self.graph_hash</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">append_to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        write the mol object to a file. E.g.:</span>
<span class="sd">        ```</span>
<span class="sd">        with jsonlines.open(path, mode=&#39;w&#39;) as writer:</span>
<span class="sd">            mol.write_to_file(key=mol.name, writer=writer)</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_to_mol_dict</span><span class="p">()}</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_mol_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                           <span class="n">dict_</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                           <span class="n">graph_creating_strategy</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;default&quot;</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span>
                           <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        generate an RCA mol object from a mol_dict,</span>
<span class="sd">        we can either take a graph or a graph dict as input for the graph so far</span>
<span class="sd">        :param graph_creating_strategy: which graph strategy to follow in order to create a graph</span>
<span class="sd">        :param kwargs: additional requirements for the graph creation, we can dump basically anything</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">{</span><span class="s2">&quot;atomic_props&quot;</span><span class="p">,</span> <span class="s2">&quot;global_props&quot;</span><span class="p">,</span> <span class="s2">&quot;graph_dict&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dict_</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;graph_dict&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">make_from_atomic_properties</span><span class="p">(</span><span class="n">atomic_props_mol</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;atomic_props&quot;</span><span class="p">],</span>
                                                   <span class="n">global_props_mol</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;global_props&quot;</span><span class="p">],</span>
                                                   <span class="n">graph_creating_strategy</span><span class="o">=</span><span class="n">graph_creating_strategy</span><span class="p">,</span>
                                                   <span class="o">**</span><span class="n">kwargs</span>
                                                   <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;graph_dict&quot;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">make_from_atomic_properties</span><span class="p">(</span><span class="n">atomic_props_mol</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;atomic_props&quot;</span><span class="p">],</span>
                                                   <span class="n">global_props_mol</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;global_props&quot;</span><span class="p">],</span>
                                                   <span class="n">graph</span><span class="o">=</span><span class="n">graph_from_graph_dict</span><span class="p">(</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;graph_dict&quot;</span><span class="p">])</span>
                                                   <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;graph_dict&quot;</span><span class="p">],</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;graph_dict&quot;</span><span class="p">],</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">make_from_atomic_properties</span><span class="p">(</span><span class="n">atomic_props_mol</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;atomic_props&quot;</span><span class="p">],</span>
                                                   <span class="n">global_props_mol</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;global_props&quot;</span><span class="p">],</span>
                                                   <span class="n">graph</span><span class="o">=</span><span class="n">unify_graph</span><span class="p">(</span><span class="n">G</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;graph_dict&quot;</span><span class="p">])</span>
                                                   <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unreadable graph format&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">make_from_atomic_properties</span><span class="p">(</span><span class="n">atomic_props_mol</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;atomic_props&quot;</span><span class="p">],</span>
                                                   <span class="n">global_props_mol</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;global_props&quot;</span><span class="p">],</span>
                                                   <span class="n">graph_creating_strategy</span><span class="o">=</span><span class="n">graph_creating_strategy</span><span class="p">,</span>
                                                   <span class="o">**</span><span class="n">kwargs</span>
                                                   <span class="p">)</span>

    <span class="k">def</span> <span class="nf">count_atoms_with_n_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">n_bonds</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">graph_element_label</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;node_label&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number of occurrences of element `element` with exactly `n_bonds` bonds.</span>
<span class="sd">        @param element (str, None): specification of the element, e.g. &#39;C&#39;. If None, all elements are counted.</span>
<span class="sd">        @param n_bonds (int): count an atom if it has exactly this number of bonds</span>
<span class="sd">        @param graph_element_label: the label of the element string in the graph attributes. Only necessary if element is not None.</span>
<span class="sd">        @return (int): integer count of the occurrences</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">count_atoms_with_n_bonds</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">element</span><span class="o">=</span><span class="n">element</span><span class="p">,</span> <span class="n">n_bonds</span><span class="o">=</span><span class="n">n_bonds</span><span class="p">,</span> <span class="n">graph_element_label</span><span class="o">=</span><span class="n">graph_element_label</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">contains_only</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span> <span class="n">except_elements</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the molecule contains only elements out of the list `atoms`, otherwise False.</span>
<span class="sd">        @param atoms: list of elements to check for</span>
<span class="sd">        @param except_elements: ignore these elements in the molecule when testing</span>
<span class="sd">        @return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">atoms</span><span class="p">]</span>

        <span class="n">own_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">except_elements</span><span class="p">]</span>
        <span class="n">contains_only_atoms</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">own_atoms</span><span class="p">,</span> <span class="n">atoms</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">contains_only_atoms</span>

    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># converting into other classes of mol objects</span>

    <span class="k">def</span> <span class="nf">to_stk_mol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">convert_RCA_to_stk_Molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_pymatMol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="kn">import</span> <span class="n">Molecule</span> <span class="k">as</span> <span class="n">PyMatMol</span>
        <span class="k">return</span> <span class="n">PyMatMol</span><span class="p">(</span><span class="n">species</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">],</span>
                        <span class="n">coords</span><span class="o">=</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="n">key_</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">key_</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span>
                                <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])])</span>




<div class="viewcode-block" id="RCA_Ligand"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand">[docs]</a><span class="k">class</span> <span class="nc">RCA_Ligand</span><span class="p">(</span><span class="n">RCA_Molecule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is used to represent ligands in the MetaLig database.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">denticity</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">ligand_to_metal</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                 <span class="n">atomic_props</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">global_props</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">other_props</span><span class="o">=</span><span class="p">{},</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param graph: If None, it will be generated custom. Maybe only important for monodentates and reactant</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coord_list_3D</span> <span class="o">=</span> <span class="p">[[</span><span class="n">atomic_props</span><span class="p">[</span><span class="n">key_</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">key_</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span>
                         <span class="nb">enumerate</span><span class="p">(</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])]</span>
        <span class="n">atom_list</span> <span class="o">=</span> <span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mol</span><span class="o">=</span><span class="n">Atoms</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">coord_list_3D</span><span class="p">),</span>
                         <span class="n">atomic_props</span><span class="o">=</span><span class="n">atomic_props</span><span class="p">,</span>
                         <span class="n">global_props</span><span class="o">=</span><span class="n">global_props</span><span class="p">,</span>
                         <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
                         <span class="n">has_ligands</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">other_props</span><span class="o">=</span><span class="n">other_props</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span>
                         <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">[</span><span class="n">at</span><span class="p">,</span> <span class="n">coord_list_3D</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">at</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_list</span><span class="p">)}</span>

        <span class="c1"># This attribute transforms the indices of atoms in the atomic properties (starting with 0 until n-1) to the corresponding indices of self.graph. This is necessary because self.graph has indices not starting at 0 and going to n-1, but it has kept the original indices from the complex. This is a historic issue that has not been solved yet.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atomic_index_to_graph_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">atm_idx</span><span class="p">:</span> <span class="n">graph_idx</span> <span class="k">for</span> <span class="n">atm_idx</span><span class="p">,</span> <span class="n">graph_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">))}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_index_to_atomic_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">graph_idx</span><span class="p">:</span> <span class="n">atm_idx</span> <span class="k">for</span> <span class="n">atm_idx</span><span class="p">,</span> <span class="n">graph_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_index_to_graph_index</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">denticity</span> <span class="o">=</span> <span class="n">denticity</span> <span class="c1"># integer denticity, -1 for unconnected</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="c1"># str name of ligand</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_complex_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">[</span><span class="s1">&#39;CSD_code&#39;</span><span class="p">]</span>

        <span class="c1"># the indices and elements where the ligands was bound to the metal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span> <span class="o">=</span> <span class="n">ligand_to_metal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_elements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_elements</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">was_connected_to_metal</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_elements</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="s2">&quot;csd_code&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">csd_code</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;csd_code&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;unique_name&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unique_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;unique_name&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;original_metal&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original_metal</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;original_metal&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;original_metal_position&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original_metal_position</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;original_metal_position&#39;</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original_metal_symbol</span> <span class="o">=</span> <span class="n">DART_Element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">original_metal</span><span class="p">)</span><span class="o">.</span><span class="n">symbol</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="s1">&#39;original_metal_os&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original_metal_os</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;original_metal_os&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_centrosymmetric</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">centrosymmetry_ang_dev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_if_centrosymmetric</span><span class="p">(</span><span class="n">return_ang_dev</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># The graph_hash_with_metal is not calculated with the real original metal, but with a pseudo metal which is always the same, so that only the connections to the metal matter, but different original metals won&#39;t give different hashes. This means ligands are considered the same independent of the original metal under this hash.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;graph_hash_with_metal&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph_hash_with_metal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph_hash_with_metal</span><span class="p">(</span><span class="n">metal_symbol</span><span class="o">=</span><span class="s1">&#39;Hg&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;heavy_atoms_graph_hash_with_metal&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">heavy_atoms_graph_hash_with_metal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_heavy_atoms_graph_hash_with_metal</span><span class="p">(</span><span class="n">metal_symbol</span><span class="o">=</span><span class="s1">&#39;Hg&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;has_betaH&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_betaH</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">betaH_check</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_neighboring_coordinating_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_for_neighboring_coordinating_atoms</span><span class="p">()</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ligand_stats</span><span class="p">()</span>

        <span class="k">assert</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;Graph of ligand with name </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> is not fully connected.&#39;</span>

<div class="viewcode-block" id="RCA_Ligand.get_ligand_stats"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.get_ligand_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_ligand_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary with potentially interesting ligand statistics.</span>
<span class="sd">        @return: Dictionary with stats</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">min_distance_to_metal</span><span class="p">,</span> <span class="n">max_distance_to_metal</span><span class="p">,</span> <span class="n">coordinating_atom_distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_atomic_distance_to_original_metal</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
        <span class="n">min_dist</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_atomic_distances_between_atoms</span><span class="p">()</span>
        <span class="n">max_dist_per_atoms</span> <span class="o">=</span> <span class="n">max_dist</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">])</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;min_distance_to_metal&#39;</span><span class="p">:</span> <span class="n">min_distance_to_metal</span><span class="p">,</span>
                    <span class="s1">&#39;max_distance_to_metal&#39;</span><span class="p">:</span> <span class="n">max_distance_to_metal</span><span class="p">,</span>
                    <span class="s1">&#39;coordinating_atom_distances_to_metal&#39;</span><span class="p">:</span> <span class="n">coordinating_atom_distances</span><span class="p">,</span>
                    <span class="s1">&#39;min_atomic_distance&#39;</span><span class="p">:</span> <span class="n">min_dist</span><span class="p">,</span>
                    <span class="s1">&#39;max_atomic_distance&#39;</span><span class="p">:</span> <span class="n">max_dist</span><span class="p">,</span>
                    <span class="s1">&#39;max_dist_per_atoms&#39;</span><span class="p">:</span> <span class="n">max_dist_per_atoms</span>
                <span class="p">}</span>

        <span class="k">return</span> <span class="n">stats</span></div>


<div class="viewcode-block" id="RCA_Ligand.calculate_angular_deviation_from_centrosymmetry"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.calculate_angular_deviation_from_centrosymmetry">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_angular_deviation_from_centrosymmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the angular deviation from centrosymmetry. Only defined for monodentate ligands.</span>
<span class="sd">        :return: Angular deviation from centrosymmetry for monodentates, np.nan for others.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">calculate_angular_deviation_of_bond_axis_from_ligand_center</span><span class="p">(</span><span class="n">atomic_props</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">,</span> <span class="n">donor_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">,</span> <span class="n">metal_position</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">original_metal_position</span><span class="p">)</span></div>

<div class="viewcode-block" id="RCA_Ligand.check_if_centrosymmetric"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.check_if_centrosymmetric">[docs]</a>    <span class="k">def</span> <span class="nf">check_if_centrosymmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">return_ang_dev</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the ligand is centrosymmetric. Only defined for monodentate ligands.</span>
<span class="sd">        @return: True if the ligand is monodentate and centrosymmetric, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">denticity</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_ang_dev</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="n">ang_dev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_angular_deviation_from_centrosymmetry</span><span class="p">()</span>
        <span class="n">centrosymmetric</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">ang_dev</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_ang_dev</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">centrosymmetric</span><span class="p">,</span> <span class="n">ang_dev</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">centrosymmetric</span></div>

<div class="viewcode-block" id="RCA_Ligand.check_bidentate_planarity"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.check_bidentate_planarity">[docs]</a>    <span class="k">def</span> <span class="nf">check_bidentate_planarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">return_deviation</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the ligand is bidentate planar. Only defined for bidentate ligands.</span>
<span class="sd">        @param tol: Maximum tolerance to be considered planar. Default is 0.7.</span>
<span class="sd">        @param return_deviation: If True, the calculated deviation is returned as well</span>
<span class="sd">        @return: True if the ligand is bidentate planar, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">denticity</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_deviation</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="n">graph</span><span class="p">,</span> <span class="n">metal_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph_with_metal</span><span class="p">(</span><span class="n">metal_symbol</span><span class="o">=</span><span class="s1">&#39;Hg&#39;</span><span class="p">,</span> <span class="n">return_metal_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">metal_idx</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_index_to_graph_index</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">&#39;node_label&#39;</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">])</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">([</span><span class="s1">&#39;Hg&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_elements</span><span class="p">),</span> <span class="n">nodes</span>

        <span class="n">ring_indices</span> <span class="o">=</span> <span class="n">find_smallest_ring_with_specified_nodes</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ring_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">is_coplanar</span><span class="p">,</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ring_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_index_to_atomic_index</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ring_indices</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">metal_idx</span><span class="p">]</span>
            <span class="n">all_coordinates</span> <span class="o">=</span> <span class="p">{</span><span class="n">idx</span><span class="p">:</span> <span class="n">coord</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates_list</span><span class="p">())}</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">original_metal_position</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">all_coordinates</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ring_indices</span><span class="p">]</span>

            <span class="n">deviation</span> <span class="o">=</span> <span class="n">get_max_deviation_from_coplanarity</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">coordinates</span><span class="p">)</span>
            <span class="n">is_coplanar</span> <span class="o">=</span> <span class="n">deviation</span> <span class="o">&lt;</span> <span class="n">tol</span>

        <span class="k">if</span> <span class="n">return_deviation</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">is_coplanar</span><span class="p">,</span> <span class="n">deviation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">is_coplanar</span></div>


<div class="viewcode-block" id="RCA_Ligand.count_atoms_with_n_bonds"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.count_atoms_with_n_bonds">[docs]</a>    <span class="k">def</span> <span class="nf">count_atoms_with_n_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">n_bonds</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">graph_element_label</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;node_label&#39;</span><span class="p">,</span> <span class="n">remember_metal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number of occurrences of element `element` with exactly `n_bonds` bonds.</span>
<span class="sd">        @param element (str, None): specification of the element, e.g. &#39;C&#39;. If None, all elements are counted.</span>
<span class="sd">        @param n_bonds (int): count an atom if it has exactly this number of bonds</span>
<span class="sd">        @param graph_element_label (str): the label of the element string in the graph attributes. Only necessary if element is not None.</span>
<span class="sd">        @param remember_metal (bool): If the original bonds to the metal should be considered or not. Only relevant for ligands.</span>
<span class="sd">        @return (int): integer count of the occurrences</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_with_metal</span> <span class="k">if</span> <span class="n">remember_metal</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">count_atoms_with_n_bonds</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">element</span><span class="o">=</span><span class="n">element</span><span class="p">,</span> <span class="n">n_bonds</span><span class="o">=</span><span class="n">n_bonds</span><span class="p">,</span> <span class="n">graph_element_label</span><span class="o">=</span><span class="n">graph_element_label</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">n</span></div>

<div class="viewcode-block" id="RCA_Ligand.get_atomic_distance"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.get_atomic_distance">[docs]</a>    <span class="k">def</span> <span class="nf">get_atomic_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span> <span class="s1">&#39;min&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distance of atoms to each other.</span>
<span class="sd">        @param mode: any of [&#39;min&#39;, &#39;max&#39;, &#39;coordinating&#39;, &#39;all&#39;]</span>
<span class="sd">        @return: Returns the specified distance(s)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">original_metal_position</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;coordinating&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">distances</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">distances</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>

<div class="viewcode-block" id="RCA_Ligand.get_atomic_distance_to_original_metal"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.get_atomic_distance_to_original_metal">[docs]</a>    <span class="k">def</span> <span class="nf">get_atomic_distance_to_original_metal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span> <span class="s1">&#39;min&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distance of the ligand from the metal. Can also be used to get the maximum distance of an atom in the ligand to the metal or the distances of all coordinating elements.</span>
<span class="sd">        @param mode: any of [&#39;min&#39;, &#39;max&#39;, &#39;coordinating&#39;, &#39;all&#39;]</span>
<span class="sd">        @return: Returns the specified distance(s)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">original_metal_position</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;coordinating&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">distances</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">distances</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>

<div class="viewcode-block" id="RCA_Ligand.get_coordinates_with_metal"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.get_coordinates_with_metal">[docs]</a>    <span class="k">def</span> <span class="nf">get_coordinates_with_metal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinates of the ligand with the metal.</span>
<span class="sd">        @return: Coordinates of the ligand with the metal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">original_metal_position</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates_list</span><span class="p">()</span></div>


<div class="viewcode-block" id="RCA_Ligand.get_graph_with_metal"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.get_graph_with_metal">[docs]</a>    <span class="k">def</span> <span class="nf">get_graph_with_metal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metal_symbol</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_metal_index</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the graph of the ligand but with the original metal connected to the coordinating atoms.</span>
<span class="sd">        @return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">graph_with_metal</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>   <span class="c1"># unfreeze graph</span>
        <span class="k">if</span> <span class="n">metal_symbol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metal_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_metal_symbol</span>

        <span class="c1"># Add metal node and bonds of coordinating atoms</span>
        <span class="n">metal_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">graph_with_metal</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">metal_idx</span><span class="p">,</span> <span class="n">node_label</span><span class="o">=</span><span class="n">metal_symbol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">:</span>
            <span class="c1"># Indices of graph and atomic indices don&#39;t match</span>
            <span class="n">graph_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_index_to_graph_index</span><span class="p">[</span><span class="n">atom_idx</span><span class="p">]</span>
            <span class="n">graph_with_metal</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">metal_idx</span><span class="p">,</span> <span class="n">graph_idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_metal_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">graph_with_metal</span><span class="p">,</span> <span class="n">metal_idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">graph_with_metal</span></div>


<div class="viewcode-block" id="RCA_Ligand.get_graph_hash_with_metal"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.get_graph_hash_with_metal">[docs]</a>    <span class="k">def</span> <span class="nf">get_graph_hash_with_metal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metal_symbol</span><span class="p">,</span> <span class="n">graph_atom_label</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span> <span class="s1">&#39;node_label&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the graph hash of the ligand including the metal and the bonds to the metal.</span>
<span class="sd">        @return: graph hash</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">graph_with_metal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph_with_metal</span><span class="p">(</span><span class="n">metal_symbol</span><span class="o">=</span><span class="n">metal_symbol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">get_graph_hash</span><span class="p">(</span><span class="n">graph_with_metal</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="n">graph_atom_label</span><span class="p">)</span></div>

<div class="viewcode-block" id="RCA_Ligand.get_heavy_atoms_graph_hash_with_metal"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.get_heavy_atoms_graph_hash_with_metal">[docs]</a>    <span class="k">def</span> <span class="nf">get_heavy_atoms_graph_hash_with_metal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metal_symbol</span><span class="p">,</span> <span class="n">graph_atom_label</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span> <span class="s1">&#39;node_label&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the graph hash of the ligand including the metal and the bonds to the metal. Only heavy atoms are considered.</span>
<span class="sd">        @return: graph hash</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">graph_with_metal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph_with_metal</span><span class="p">(</span><span class="n">metal_symbol</span><span class="o">=</span><span class="n">metal_symbol</span><span class="p">)</span>
        <span class="n">heavy_graph_with_metal</span> <span class="o">=</span> <span class="n">get_heavy_atoms_graph</span><span class="p">(</span><span class="n">graph_with_metal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">get_graph_hash</span><span class="p">(</span><span class="n">heavy_graph_with_metal</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="n">graph_atom_label</span><span class="p">)</span></div>


<div class="viewcode-block" id="RCA_Ligand.get_local_elements"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.get_local_elements">[docs]</a>    <span class="k">def</span> <span class="nf">get_local_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the elements in the first coordination sphere from `self.ligand_to_metal`.</span>
<span class="sd">        :return: list of elements in first coordination sphere</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">]</span></div>

<div class="viewcode-block" id="RCA_Ligand.betaH_check"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.betaH_check">[docs]</a>    <span class="k">def</span> <span class="nf">betaH_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_label</span><span class="o">=</span><span class="s1">&#39;node_label&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the ligand has beta Hydrogen. Alpha H is ignored. Beta H is defined as a H atom which is exactly two bonds away from a coordinating atom.</span>
<span class="sd">        @return: True if beta Hydrogen is present, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reindexed_graph</span><span class="p">()</span>     <span class="c1"># historical issue</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">get_adjacency_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

        <span class="c1"># The second power of the adjacency matrix, i.e. A^2[i,j] represents the number of paths of length two</span>
        <span class="c1"># from i to j. Hence, as we are only interested in Hydrogen which has a distance of two to our functional atoms</span>
        <span class="c1"># we can make quick use of that</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">functional_index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">atom_symbol</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">node_label</span><span class="p">):</span>
                <span class="c1"># search for beta Hydrogen while excluding alpha Hydrogen</span>
                <span class="k">if</span> <span class="n">B</span><span class="p">[</span><span class="n">functional_index</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">functional_index</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">atom_symbol</span> <span class="o">==</span> <span class="s2">&quot;H&quot;</span><span class="p">:</span>
                    <span class="c1"># self.view_3d()</span>
                    <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="RCA_Ligand.check_for_neighboring_coordinating_atoms"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.check_for_neighboring_coordinating_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">check_for_neighboring_coordinating_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if any of the coordinating atoms are neighbors.</span>
<span class="sd">        @return: True if two coordinating atoms are neighbors, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">:</span>
                <span class="c1"># Indices of graph and atomic indices don&#39;t match historically</span>
                <span class="n">graph_index_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_index_to_graph_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">graph_index_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_index_to_graph_index</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">graph_index_i</span><span class="p">,</span> <span class="n">graph_index_j</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="RCA_Ligand.sort_atomic_props_to_have_coordinating_atoms_first"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.sort_atomic_props_to_have_coordinating_atoms_first">[docs]</a>    <span class="k">def</span> <span class="nf">sort_atomic_props_to_have_coordinating_atoms_first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts the atomic properties such that the atoms that are coordinating are first in the list.</span>
<span class="sd">        Attention: This does not change anything else, only the atomic properties. The graph and the ligand_to_metal are still the same!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">]</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="RCA_Ligand.get_assembly_dict"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.get_assembly_dict">[docs]</a>    <span class="k">def</span> <span class="nf">get_assembly_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        only to get the attributes required for the assembly with cians script a little faster</span>
<span class="sd">        :return: {index: list, type: list, xyz_str: str}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dict_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span>
        <span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">]</span>
        <span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;str&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xyz_file_format_string</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">dict_</span></div>

<div class="viewcode-block" id="RCA_Ligand.add_atom"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.add_atom">[docs]</a>    <span class="k">def</span> <span class="nf">add_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Wrong number of coordinates specified&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># now we need to update the self.mol, graph wont be updated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_to_xyz</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="s2">&quot;../tmp/tmp.xyz&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;../tmp/tmp.xyz&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="RCA_Ligand.functional_atom_check"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.functional_atom_check">[docs]</a>    <span class="k">def</span> <span class="nf">functional_atom_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms_of_interest</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">atoms_of_interest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atoms_of_interest</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;O&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms_of_interest</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">atoms_of_interest</span> <span class="o">=</span> <span class="p">[</span><span class="n">atoms_of_interest</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_assembly_dict</span><span class="p">()[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">atoms_of_interest</span><span class="p">))</span></div>


    <span class="c1"># todo: unittests!!</span>
<div class="viewcode-block" id="RCA_Ligand.planar_check"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.planar_check">[docs]</a>    <span class="k">def</span> <span class="nf">planar_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the ligand has planar donor atoms. Check is done only for denticity 3 and 4, otherwise False is returned.</span>
<span class="sd">        :param eps: durch try&#39;n&#39;error obtained</span>
<span class="sd">        eps für (d=4) -&gt; 1</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">denticity</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">functional_coords</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligand_to_metal</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">functional_coords</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">denticity</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Error in Planar Check for ligand </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">denticity</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">functional_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">functional_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">functional_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">Point3D</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">round</span><span class="p">(</span><span class="n">E</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">c3</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">denticity</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c4</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">functional_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">functional_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">Point3D</span><span class="p">(</span>
                <span class="n">functional_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">functional_coords</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">round</span><span class="p">(</span><span class="n">E</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">c4</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="RCA_Ligand.get_ligand_output_info"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.get_ligand_output_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_ligand_output_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_entries</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">important_data</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;unique_name&#39;</span><span class="p">,</span> <span class="s1">&#39;stoichiometry&#39;</span><span class="p">,</span> <span class="s1">&#39;denticity&#39;</span><span class="p">,</span> <span class="s1">&#39;local_elements&#39;</span><span class="p">,</span> <span class="s1">&#39;pred_charge&#39;</span><span class="p">,</span> <span class="s1">&#39;pred_charge_is_confident&#39;</span><span class="p">,</span> <span class="s1">&#39;graph_hash_with_metal&#39;</span><span class="p">,</span>  <span class="s1">&#39;occurrences&#39;</span><span class="p">,</span> <span class="s1">&#39;count_metals&#39;</span><span class="p">,</span> <span class="s1">&#39;all_ligand_names&#39;</span><span class="p">]</span>
        <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_to_mol_dict</span><span class="p">(</span><span class="n">include_graph_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">info</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">important_data</span><span class="p">}</span>

        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;Ligand ID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;unique_name&#39;</span><span class="p">]</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;Stoichiometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;stoichiometry&#39;</span><span class="p">]</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;Denticity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;denticity&#39;</span><span class="p">]</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;Donors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;local_elements&#39;</span><span class="p">])</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;Predicted Charge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pred_charge&#39;</span><span class="p">])</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pred_charge&#39;</span><span class="p">])</span> <span class="k">else</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;pred_charge&#39;</span><span class="p">]</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;Confident Charge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;pred_charge_is_confident&#39;</span><span class="p">]</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;Graph ID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;graph_hash_with_metal&#39;</span><span class="p">]</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;CSD Occurrences&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;occurrences&#39;</span><span class="p">]</span>
        <span class="c1"># Currently doesn&#39;t work because the ligand doesn&#39;t have the attribute &#39;identical_ligand_info&#39;</span>
        <span class="c1"># csd_mos_counts = [f&#39;{el}+{mos:.0f}&#39; if mos &gt; 0 else f&#39;{el}+{mos:.0f}&#39; for el, mos in zip(self.identical_ligand_info[&#39;original_metal_symbol&#39;], self.identical_ligand_info[&#39;original_metal_os&#39;]) if not np.isnan(mos)]</span>
        <span class="c1"># csd_mos_counts = pd.value_counts(pd.Series(csd_mos_counts)).to_dict()</span>
        <span class="c1"># info[&#39;CSD Metal OS Count&#39;] = &#39;, &#39;.join([f&#39;{el}({count})&#39; for el, count in csd_mos_counts.items()])</span>

        <span class="c1"># Get CSD complex IDs, but truncate if there are too many</span>
        <span class="n">truncate_data</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s1">&#39;CSD Complex IDs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;CSD-&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;all_ligand_names&#39;</span><span class="p">])],</span>
                            <span class="s1">&#39;CSD Metal Count&#39;</span><span class="p">:</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">el</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s1">)&#39;</span> <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;count_metals&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
                        <span class="p">}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">truncate_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">n_data</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="n">max_entries</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_data</span> <span class="o">&gt;</span> <span class="n">max_entries</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;, ... (</span><span class="si">{</span><span class="n">n_data</span> <span class="o">-</span> <span class="n">max_entries</span><span class="si">}</span><span class="s1"> more)&#39;</span>
            <span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>


        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">important_data</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">info</span></div>

<div class="viewcode-block" id="RCA_Ligand.write_to_mol_dict"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.write_to_mol_dict">[docs]</a>    <span class="k">def</span> <span class="nf">write_to_mol_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_graph_dict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Manually initialize special fields</span>
        <span class="k">if</span> <span class="n">include_graph_dict</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;graph_dict&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph_to_dict_with_node_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>

        <span class="n">do_not_output_automatically</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mol&#39;</span><span class="p">,</span> <span class="s1">&#39;node_label&#39;</span><span class="p">,</span> <span class="s1">&#39;rdkit_mol&#39;</span><span class="p">,</span> <span class="s1">&#39;graph&#39;</span><span class="p">,</span> <span class="s1">&#39;coordinates&#39;</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">,</span> <span class="s1">&#39;csd_code&#39;</span><span class="p">,</span> <span class="s1">&#39;graph_with_metal&#39;</span><span class="p">,</span> <span class="s1">&#39;atomic_index_to_graph_index&#39;</span><span class="p">,</span> <span class="s1">&#39;graph_index_to_atomic_index&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">prop</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">do_not_output_automatically</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">prop</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="RCA_Ligand.read_from_mol_dict"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.read_from_mol_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_mol_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dict_</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the ligand from a provided dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">necessary_props</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;atomic_props&quot;</span><span class="p">,</span> <span class="s2">&quot;global_props&quot;</span><span class="p">,</span> <span class="s2">&quot;graph_dict&quot;</span><span class="p">,</span> <span class="s2">&quot;denticity&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s1">&#39;ligand_to_metal&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">necessary_props</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dict_</span><span class="o">.</span><span class="n">keys</span><span class="p">())),</span> <span class="sa">f</span><span class="s1">&#39;Any of the necessary keys </span><span class="si">{</span><span class="n">necessary_props</span><span class="si">}</span><span class="s1"> is not present.&#39;</span>

        <span class="c1"># Add default properties for properties not in the json. This is useful for properties which have been introduced in later versions of the code.</span>
        <span class="n">optional_props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;warnings&#39;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">for</span> <span class="n">prop</span><span class="p">,</span> <span class="n">default</span> <span class="ow">in</span> <span class="n">optional_props</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">dict_</span><span class="p">:</span>
                <span class="n">dict_</span><span class="p">[</span><span class="n">prop</span><span class="p">]</span> <span class="o">=</span> <span class="n">default</span>

        <span class="n">other_props</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dict_</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">necessary_props</span><span class="p">}</span>

        <span class="c1"># Optionally add graph if it is present in the dictionary</span>
        <span class="k">if</span> <span class="s1">&#39;graph_dict&#39;</span> <span class="ow">in</span> <span class="n">dict_</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dict_</span><span class="p">[</span><span class="s1">&#39;graph_dict&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">graph_from_graph_dict</span><span class="p">(</span><span class="n">dict_</span><span class="p">[</span><span class="s1">&#39;graph_dict&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">atomic_props</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;atomic_props&quot;</span><span class="p">],</span>
            <span class="n">global_props</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;global_props&quot;</span><span class="p">],</span>
            <span class="n">denticity</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;denticity&quot;</span><span class="p">],</span>
            <span class="n">name</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
            <span class="n">ligand_to_metal</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s1">&#39;ligand_to_metal&#39;</span><span class="p">],</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">warnings</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s1">&#39;warnings&#39;</span><span class="p">],</span>
            <span class="n">other_props</span><span class="o">=</span><span class="n">other_props</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>

    <span class="c1"># some stk functionality</span>
<div class="viewcode-block" id="RCA_Ligand.to_stk_bb"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.to_stk_bb">[docs]</a>    <span class="k">def</span> <span class="nf">to_stk_bb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        this is really only designed for ligands as a normal RCA_Molecule doesn&#39;t have the required properties</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">RCA_Mol_to_stkBB</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="RCA_Ligand.get_ase_molecule_with_metal"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.get_ase_molecule_with_metal">[docs]</a>    <span class="k">def</span> <span class="nf">get_ase_molecule_with_metal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metal</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Atoms</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get ASE molecule with metal at original metal location. If no metal is specified, the original metal is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_metal_symbol</span>

        <span class="c1"># Get ASE molecule</span>
        <span class="n">ase_mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ase_molecule</span><span class="p">(</span><span class="n">add_atoms</span><span class="o">=</span><span class="p">[(</span><span class="n">metal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_metal_position</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">ase_mol</span></div>

<div class="viewcode-block" id="RCA_Ligand.get_xtb_descriptors"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.get_xtb_descriptors">[docs]</a>    <span class="k">def</span> <span class="nf">get_xtb_descriptors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return xtb descriptors for the molecule. Needs xtb installed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">dev.src11_machine_learning.utils.utilities_ML</span> <span class="kn">import</span> <span class="n">get_xtb_descriptors</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">charge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_charge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xtb_descriptors</span> <span class="o">=</span> <span class="n">get_xtb_descriptors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_xyz_file_format_string</span><span class="p">(),</span> <span class="n">charge</span><span class="o">=</span><span class="n">charge</span><span class="p">,</span>
                                                       <span class="n">n_unpaired</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xtb_descriptors</span> <span class="o">=</span> <span class="p">{</span>
                                <span class="s1">&#39;ionization_potential&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                                <span class="s1">&#39;electron_affinity&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                                <span class="s1">&#39;HOMO&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                                <span class="s1">&#39;LUMO&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                                <span class="s1">&#39;Dipole_x&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                                <span class="s1">&#39;Dipole_y&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                                <span class="s1">&#39;Dipole_z&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                                <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xtb_descriptors</span></div>

<div class="viewcode-block" id="RCA_Ligand.generate_descriptors"><a class="viewcode-back" href="../../../../doc_files/ligands/ligands.html#DARTassembler.src.ligand_extraction.Molecule.RCA_Ligand.generate_descriptors">[docs]</a>    <span class="k">def</span> <span class="nf">generate_descriptors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">get_3D_descriptors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates descriptors for the ligand. Needs pymatgen and mordred installed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">src11_machine_learning.utils.utilities_ML</span> <span class="kn">import</span> <span class="n">get_element_descriptors</span>
        <span class="n">descriptors</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Global descriptors</span>
        <span class="n">descriptors</span><span class="p">[</span><span class="s1">&#39;denticiy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">denticity</span>
        <span class="n">descriptors</span><span class="p">[</span><span class="s1">&#39;planar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">planar_check</span><span class="p">()</span>
        <span class="n">descriptors</span><span class="p">[</span><span class="s1">&#39;molecular_weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">[</span><span class="s1">&#39;molecular_weight&#39;</span><span class="p">]</span>
        <span class="n">descriptors</span><span class="p">[</span><span class="s1">&#39;n_atoms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span>
        <span class="n">descriptors</span><span class="p">[</span><span class="s1">&#39;n_bonds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_bonds</span>

        <span class="c1"># Coordinated atoms descriptors</span>
        <span class="n">coords_descriptors</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_element_descriptors</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_elements</span><span class="p">]</span>
        <span class="n">coords_descriptors</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">coords_descriptors</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span>
                              <span class="n">coords_descriptors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">descriptors</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">coords_descriptors</span><span class="p">)</span>

        <span class="c1"># Graph and 3D descriptors</span>
        <span class="kn">import</span> <span class="nn">mordred</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_smiles</span><span class="p">())</span>
        <span class="n">calc</span> <span class="o">=</span> <span class="n">mordred</span><span class="o">.</span><span class="n">Calculator</span><span class="p">(</span><span class="n">descriptors</span><span class="p">,</span> <span class="n">ignore_3D</span><span class="o">=</span><span class="ow">not</span> <span class="n">get_3D_descriptors</span><span class="p">)</span>
        <span class="n">mordred_descriptors</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">pandas</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;records&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">descriptors</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mordred_descriptors</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">descriptors</span></div></div>



<span class="k">class</span> <span class="nc">RCA_Complex</span><span class="p">(</span><span class="n">RCA_Molecule</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">mol</span><span class="p">:</span> <span class="n">Atoms</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">atomic_props</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">global_props</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">pymat_mol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">graph_creating_strategy</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span>
                 <span class="n">has_ligands</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">reindex_graph</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">other_props</span><span class="o">=</span><span class="p">{},</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                            <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span>
                            <span class="n">atomic_props</span><span class="o">=</span><span class="n">atomic_props</span><span class="p">,</span>
                            <span class="n">global_props</span><span class="o">=</span><span class="n">global_props</span><span class="p">,</span>
                            <span class="n">pymat_mol</span><span class="o">=</span><span class="n">pymat_mol</span><span class="p">,</span>
                            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
                            <span class="n">graph_creating_strategy</span><span class="o">=</span><span class="n">graph_creating_strategy</span><span class="p">,</span>
                            <span class="n">has_ligands</span><span class="o">=</span><span class="n">has_ligands</span><span class="p">,</span>
                            <span class="n">reindex_graph</span><span class="o">=</span><span class="n">reindex_graph</span><span class="p">,</span>
                            <span class="n">other_props</span><span class="o">=</span><span class="n">other_props</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span>
                             <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_if_graph_and_coordinates_are_consistent</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shift_metal_to_origin</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">metal</span> <span class="o">=</span> <span class="n">identify_metal_in_ase_mol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metal_atomic_number</span> <span class="o">=</span> <span class="n">DART_Element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metal</span><span class="p">)</span><span class="o">.</span><span class="n">atomic_number</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metal_oxi_state</span> <span class="o">=</span> <span class="n">make_None_to_NaN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">[</span><span class="s1">&#39;metal_oxi_state&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="n">make_None_to_NaN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">[</span><span class="s1">&#39;charge&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metal_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metal</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metal_position</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_idx</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fully_connected</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">donor_indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_idx</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">donor_elements</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">donor_indices</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_donors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">donor_indices</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">metal_position</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_idx</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fully_connected</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">[</span><span class="s1">&#39;CSD_code&#39;</span><span class="p">]</span>

            <span class="c1"># Set parameters for octahedral complexes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_octahedral</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_octahedral</span><span class="p">()</span>
            <span class="n">mean_distance</span><span class="p">,</span> <span class="n">sd_distance</span><span class="p">,</span> <span class="n">max_angular_deviation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_distortion_parameters</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">[</span><span class="s1">&#39;donors_mean_dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_distance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">[</span><span class="s1">&#39;donors_sd_dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd_distance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">[</span><span class="s1">&#39;oct_max_ang_dev&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_angular_deviation</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">add_additional_complex_information_to_global_props</span><span class="p">()</span>

            <span class="k">return</span>

    <span class="k">def</span> <span class="nf">has_metal_os</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_oxi_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">calculate_distortion_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to calculate distortion parameters of the complex</span>
<span class="sd">        :return: sd_distance (standard deviation of neighbour distances from the metal atom) and max_angular_deviation (maximum deviation from 90 or 180 degrees in bond angles)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate neighbour distances and positions</span>
        <span class="n">metal_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_position</span><span class="p">)</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">donor_indices</span>
        <span class="n">neighbour_positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">neighbour_distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">neighbour_idx</span> <span class="ow">in</span> <span class="n">neighbours</span><span class="p">:</span>
            <span class="n">neighbour_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">][</span><span class="n">neighbour_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">neighbour_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="n">neighbour_idx</span><span class="p">]])</span>
            <span class="n">neighbour_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_pos</span><span class="p">)</span>
            <span class="n">neighbour_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">neighbour_pos</span> <span class="o">-</span> <span class="n">metal_pos</span><span class="p">))</span>

        <span class="c1"># Calculate standard deviation of neighbour distances</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbour_distances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mean_distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">neighbour_distances</span><span class="p">))</span>
            <span class="n">sd_distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">neighbour_distances</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mean_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">sd_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Calculate maximum angular deviation for octahedral complexes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbours</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">max_angular_deviation</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbour_positions</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbour_positions</span><span class="p">)):</span>
                    <span class="c1"># Calculate the vector from the metal to the neighbours</span>
                    <span class="n">vector_i</span> <span class="o">=</span> <span class="n">neighbour_positions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">metal_pos</span>
                    <span class="n">vector_j</span> <span class="o">=</span> <span class="n">neighbour_positions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">metal_pos</span>

                    <span class="c1"># Calculate the angle between these vectors</span>
                    <span class="n">cos_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vector_i</span><span class="p">,</span> <span class="n">vector_j</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector_j</span><span class="p">))</span>
                    <span class="n">cos_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">cos_angle</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Ensure cos_angle is within the valid range [-1, 1]</span>
                    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cos_angle</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="c1"># Convert to degrees</span>

                    <span class="c1"># Check the angular deviation from 90 or 180 degrees</span>
                    <span class="n">angular_deviation</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">angle</span> <span class="o">-</span> <span class="mi">90</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">angle</span> <span class="o">-</span> <span class="mi">180</span><span class="p">))</span>
                    <span class="n">max_angular_deviation</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_angular_deviation</span><span class="p">,</span> <span class="n">angular_deviation</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_angular_deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="n">mean_distance</span><span class="p">,</span> <span class="n">sd_distance</span><span class="p">,</span> <span class="n">max_angular_deviation</span>

    <span class="k">def</span> <span class="nf">check_octahedral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angular_threshold</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to check if the complex is octahedral or not</span>
<span class="sd">        The conditions for a complex to be octahedral are:</span>
<span class="sd">            - The complex must have 6 donor atoms</span>
<span class="sd">            - The maximum deviation from 90 or 180 degrees in bond angles should be less than `angular_threshold`</span>
<span class="sd">        :return: True if the complex is octahedral, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">donor_indices</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">max_angular_deviation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_distortion_parameters</span><span class="p">()</span>
        <span class="n">is_oct</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">max_angular_deviation</span> <span class="o">&gt;</span> <span class="n">angular_threshold</span><span class="p">)</span>    <span class="c1"># bool() for json serialisation</span>

        <span class="k">return</span> <span class="n">is_oct</span>

    <span class="k">def</span> <span class="nf">count_ligands_with_stoichiometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">only_connected</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">atoms</span><span class="p">]</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">lig</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligands</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">only_connected</span> <span class="ow">or</span> <span class="n">lig</span><span class="o">.</span><span class="n">was_connected_to_metal</span><span class="p">:</span>
                <span class="n">lig_atoms</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">lig</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">atoms</span> <span class="o">==</span> <span class="n">lig_atoms</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">count_n_unconnected_ligands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_n_atoms</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts the number of unconnected ligands with a maximum number of atoms of `max_n_atoms`.</span>
<span class="sd">        @param max_n_atoms: Maximum number of atoms of ligands to count</span>
<span class="sd">        @return: Number of ligands with this maximum number of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="ow">not</span> <span class="n">lig</span><span class="o">.</span><span class="n">was_connected_to_metal</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lig</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">max_n_atoms</span> <span class="k">for</span> <span class="n">lig</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligands</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">n</span>


    <span class="k">def</span> <span class="nf">count_atoms_in_ligands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">only_if_connected_to_metal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">per_ligand</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of occurrences of the specified elements in the complex.</span>
<span class="sd">        @param atoms: list of atoms to count the total occurrences</span>
<span class="sd">        @param only_if_connected_to_metal: If True, ignore unconnected ligands</span>
<span class="sd">        @param per_ligand:If True, returns a list of occupancies for each ligand. Otherwise returns the total for all complexes.</span>
<span class="sd">        @return: Number of occurrences of specified elements, either as list per ligand or the total as integer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">atoms</span><span class="p">]</span>

        <span class="n">n</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lig</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligands</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">only_if_connected_to_metal</span> <span class="ow">and</span> <span class="n">lig</span><span class="o">.</span><span class="n">was_connected_to_metal</span><span class="p">:</span>
                <span class="n">n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">el</span> <span class="ow">in</span> <span class="n">atoms</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">lig</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]]))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">per_ligand</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">get_only_complex_graph_connected_to_metal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_label</span><span class="p">:</span> <span class="nb">object</span> <span class="o">=</span> <span class="s1">&#39;node_label&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the graph of only the metal complex without unconnected ligands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">complex_graph</span> <span class="o">=</span> <span class="n">get_only_complex_graph_connected_to_metal</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">atom_label</span><span class="o">=</span><span class="n">atom_label</span><span class="p">,</span> <span class="n">metal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">complex_graph</span>

    <span class="k">def</span> <span class="nf">has_fragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frag</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the complex graph has an unconnected fragment with the elements specified in frag.</span>
<span class="sd">        @param frag: Either a string specifying a single atom or a list of strings specifying several atoms. E.g. frag=&#39;Cl&#39; checks if any unconnected chloride exists. frag=&#39;[H, H, O]&#39; checks whether any unconnected water exists. The order in the list doesn&#39;t matter but the number of occurrences of elements does matter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">frag</span> <span class="o">=</span> <span class="p">[</span><span class="n">frag</span><span class="p">]</span>

        <span class="n">fragments</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)]</span>
        <span class="n">el_fragments</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fragment</span><span class="p">]</span> <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">]</span>

        <span class="n">has_unconnected_fragment</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">frag</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="n">el_fragments</span><span class="p">:</span>
            <span class="n">fragment</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fragment</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fragment</span> <span class="o">==</span> <span class="n">frag</span><span class="p">:</span>
                <span class="n">has_unconnected_fragment</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">has_unconnected_fragment</span>

    <span class="k">def</span> <span class="nf">count_ligands_containing_only</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span> <span class="n">denticity_range</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[],</span> <span class="n">n_atoms_range</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[],</span> <span class="n">except_elements</span><span class="o">=</span><span class="p">[])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count how many ligands contain only atoms specified in `atoms`, except for elements in `except elements`.</span>
<span class="sd">        @param atoms: atoms to check for.</span>
<span class="sd">        @param denticity_range: if specified, count ligands only if it has a denticity in this range (inclusive)</span>
<span class="sd">        @param n_atoms_range: if specified, count ligands only if the number of atoms which are not excluded by `except_element` is in this range (inclusive)</span>
<span class="sd">        @param except_elements: Ignore these elements in the ligands when checking the presence of the atoms in the ligand and when checking n_atoms_range.</span>
<span class="sd">        @return: Integer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">lig</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligands</span><span class="p">:</span>
            <span class="n">correct_denticity</span> <span class="o">=</span> <span class="n">is_between</span><span class="p">(</span><span class="n">lig</span><span class="o">.</span><span class="n">denticity</span><span class="p">,</span> <span class="n">denticity_range</span><span class="p">)</span>
            <span class="n">correct_n_atoms</span> <span class="o">=</span> <span class="n">is_between</span><span class="p">(</span><span class="nb">len</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">lig</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">except_elements</span><span class="p">]),</span> <span class="n">n_atoms_range</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">correct_denticity</span> <span class="ow">and</span> <span class="n">correct_n_atoms</span> <span class="ow">and</span> <span class="n">lig</span><span class="o">.</span><span class="n">contains_only</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">except_elements</span><span class="o">=</span><span class="n">except_elements</span><span class="p">):</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">n</span>


    <span class="k">def</span> <span class="nf">count_coordinating_atoms_with_distance_to_metal_greater_than</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">element</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_n_atoms</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of coordinating atoms of type `element` with a distance to the metal greater than `distance`.</span>
<span class="sd">        @param max_n_atoms: Include only ligands with a number of atoms up to this number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">lig</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligands</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lig</span><span class="o">.</span><span class="n">local_elements</span><span class="p">):</span>
                <span class="n">correct_atom</span> <span class="o">=</span> <span class="n">el</span> <span class="o">==</span> <span class="n">element</span> <span class="ow">or</span> <span class="n">element</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">correct_atom</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lig</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">max_n_atoms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">lig</span><span class="o">.</span><span class="n">get_atomic_distance_to_original_metal</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;coordinating&#39;</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="p">:</span>
                        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">has_consistent_stoichiometry_with_CSD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">print_different_elements</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">csd_stoichiometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">[</span><span class="s1">&#39;CSD_stoichiometry&#39;</span><span class="p">]</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;[A-Z][a-z]?\d*&#39;</span>
            <span class="n">csd_stoichiometry</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">csd_stoichiometry</span><span class="p">))</span>
            <span class="n">csd_comp</span> <span class="o">=</span> <span class="n">Composition</span><span class="p">(</span><span class="n">csd_stoichiometry</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Global property `CSD_stoichiometry` not found. Skip check for consistent stoichiometry with xyz.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;CSD_stoichiometry could not be parsed for complex </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mol_id</span><span class="si">}</span><span class="s1">. Skip check for consistent stoichiometry with xyz.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">xyz_comp</span> <span class="o">=</span> <span class="n">Composition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stoichiometry</span><span class="p">)</span>
        <span class="n">consistent</span> <span class="o">=</span> <span class="n">csd_comp</span><span class="o">.</span><span class="n">almost_equals</span><span class="p">(</span><span class="n">xyz_comp</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">consistent</span> <span class="ow">and</span> <span class="n">print_different_elements</span><span class="p">:</span>
            <span class="n">xyz_elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">DART_Element</span><span class="p">(</span><span class="n">el</span><span class="p">)</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">xyz_comp</span><span class="o">.</span><span class="n">elements</span><span class="p">]</span>
            <span class="n">csd_elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">DART_Element</span><span class="p">(</span><span class="n">el</span><span class="p">)</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">csd_comp</span><span class="o">.</span><span class="n">elements</span><span class="p">]</span>
            <span class="n">different_elements</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">xyz_elements</span><span class="p">)</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">csd_elements</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">different_elements</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Differing elements in stoichiometries of xyz and CSD in complex </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mol_id</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">different_elements</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">diff_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">el</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">xyz_comp</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="o">-</span><span class="n">csd_comp</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">el</span><span class="p">])</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">csd_elements</span><span class="o">+</span><span class="n">xyz_elements</span><span class="p">)}</span>
            <span class="n">diff_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">diff_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">}</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Different elements counts for complex </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mol_id</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">diff_dict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">consistent</span>

    <span class="k">def</span> <span class="nf">has_consistent_stoichiometry_with_smiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ignore_element_count</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_warnings</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">only_complex</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mol_graph</span> <span class="o">=</span> <span class="n">read_smiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">explicit_hydrogen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zero_order_bonds</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">only_complex</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">frag_atoms</span> <span class="o">=</span> <span class="n">get_graph_fragments</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">mol_graph</span><span class="p">,</span> <span class="n">atom_label</span><span class="o">=</span><span class="s1">&#39;element&#39;</span><span class="p">)</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">frag_atoms</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metal</span> <span class="ow">in</span> <span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">atoms</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_sorted_atoms_and_indices_from_graph</span><span class="p">(</span><span class="n">mol_graph</span><span class="p">,</span> <span class="n">atom_label</span><span class="o">=</span><span class="s1">&#39;element&#39;</span><span class="p">)</span>

            <span class="n">comp</span> <span class="o">=</span> <span class="n">Composition</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_warnings</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Global property `smiles` not found. Skip check for consistent stoichiometry with xyz.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_warnings</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Smiles could not be parsed for complex </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mol_id</span><span class="si">}</span><span class="s1">. Skip check for consistent stoichiometry with xyz.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">only_complex</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">frag_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph_fragments</span><span class="p">()</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">frag_atoms</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metal</span> <span class="ow">in</span> <span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xyz_comp</span> <span class="o">=</span> <span class="n">Composition</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xyz_comp</span> <span class="o">=</span> <span class="n">Composition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stoichiometry</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ignore_element_count</span><span class="p">:</span>
            <span class="c1"># Check only if the same elements occur, not if the elements have the same count.</span>
            <span class="n">xyz_elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">DART_Element</span><span class="p">(</span><span class="n">el</span><span class="p">)</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">xyz_comp</span><span class="o">.</span><span class="n">elements</span><span class="p">]</span>
            <span class="n">csd_elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">DART_Element</span><span class="p">(</span><span class="n">el</span><span class="p">)</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">elements</span><span class="p">]</span>
            <span class="n">different_elements</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">xyz_elements</span><span class="p">)</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">csd_elements</span><span class="p">)</span>
            <span class="n">consistent</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">different_elements</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">consistent</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">almost_equals</span><span class="p">(</span><span class="n">xyz_comp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">consistent</span>


    <span class="k">def</span> <span class="nf">complex_is_biggest_fragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_complexes_greater_than</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the complex (fragment with the transition metal) is the fragment with the most atoms. This is useful to check whether the transition metal might not belong to an actual complex but to a counterion.</span>
<span class="sd">        :param allow_complexes_greater_than: Always return true for complexes with a higher number of atoms than this parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">el_fragments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph_fragments</span><span class="p">()</span>

        <span class="n">max_n_other_atoms</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_complex_atoms</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">el_fragments</span><span class="p">:</span>
            <span class="n">is_complex</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="n">DART_Element</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span><span class="o">.</span><span class="n">atomic_number</span> <span class="ow">in</span> <span class="n">metals_in_pse</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">is_complex</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">n_complex_atoms</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;There seem to be complexes with more than one transition metal in complex </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mol_id</span><span class="si">}</span><span class="s1">.&#39;</span>
                <span class="n">n_complex_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_n_other_atoms</span><span class="p">:</span>
                    <span class="n">max_n_other_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">n_complex_atoms</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;There seem to be no transition metals in complex </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mol_id</span><span class="si">}</span><span class="s1">.&#39;</span>

        <span class="k">if</span> <span class="n">max_n_other_atoms</span> <span class="o">&gt;</span> <span class="n">n_complex_atoms</span> <span class="ow">and</span> <span class="n">n_complex_atoms</span> <span class="o">&lt;=</span> <span class="n">allow_complexes_greater_than</span><span class="p">:</span>
            <span class="n">is_biggest_fragment</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># print(f&#39;N complex atoms in {self.mol_id}: {n_complex_atoms}&#39;)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_biggest_fragment</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">is_biggest_fragment</span>

    <span class="k">def</span> <span class="nf">add_additional_complex_information_to_global_props</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s1">&#39;partial_charge&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">:</span>
            <span class="n">metal_q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;partial_charge&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metal</span><span class="p">)]</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;metal_partial_charge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">metal_q</span>

        <span class="n">update_dict_with_warning_inplace</span><span class="p">(</span>
                                            <span class="n">dict_to_update</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">,</span>
                                            <span class="n">dict_with_information</span><span class="o">=</span><span class="n">info</span>
                                        <span class="p">)</span>

        <span class="k">return</span> <span class="n">info</span>

    <span class="k">def</span> <span class="nf">shift_metal_to_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Actually, this method is outdated not required.</span>
<span class="sd">        However, the idea was to shift the molecule to the origin, so that the metal is right in the origin</span>
<span class="sd">        which is the first part - the shift</span>

<span class="sd">        and afterwards, rotate the the metal, so that one of the functional atoms is algined with the x-axis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># get shift vector</span>
        <span class="n">metal_symb</span> <span class="o">=</span> <span class="n">identify_metal_in_ase_mol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">metal_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">metal_symb</span><span class="p">)</span>

        <span class="c1"># do the shifting</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">metal_index</span><span class="p">]</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # Now we rotate. First we identify the element we want to rotate on</span>
<span class="sd">        metal_node = find_node_in_graph_by_label(G=self.graph, label_to_find=metal_symb, expected_hits=1)</span>
<span class="sd">        rotation_element_index = list(self.graph.neighbors(metal_node))[0]</span>
<span class="sd">        # Next, we obtain the rotation matrix</span>
<span class="sd">        rotation_element_vector = np.array([self.atomic_props[key][rotation_element_index] for key in [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]])</span>
<span class="sd">            # now we can idenftify the desired vector, on which we&#39;d like to rotate the vector</span>
<span class="sd">        desired_rotation = np.array([np.linalg.norm(rotation_element_vector), 0, 0])</span>
<span class="sd">        # and we can thus find the rotation matrix</span>
<span class="sd">        A = R.align_vectors(rotation_element_vector.reshape(-1, 1).T, desired_rotation.reshape(-1, 1).T)[0].as_matrix()</span>
<span class="sd">        for index, _ in enumerate(self.atomic_props[&quot;x&quot;]):</span>
<span class="sd">            location_vec_for_index = np.array([self.atomic_props[key][index] for key in [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]])</span>
<span class="sd">            # now we rotate</span>
<span class="sd">            v_new = location_vec_for_index.dot(A)</span>
<span class="sd">            # and we modify the atomic properties</span>
<span class="sd">            for i, key in enumerate([&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]):</span>
<span class="sd">                self.atomic_props[key][index] = v_new.tolist()[i] if abs(v_new.tolist()[i]) &gt; 0.001 else 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">de_assemble</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inherit_global_properties</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;CSD_code&#39;</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        now only graph based, makeslife waaay easier</span>

<span class="sd">        All that is based on the following assumption:</span>
<span class="sd">        the nodes are denoted as integers and we shall assume that these integers</span>
<span class="sd">        correspond to their index in the atomic properties, i.e. the position</span>
<span class="sd">        so, for example for node 1, the x-coordinate can be found by</span>
<span class="sd">        self.atomic_props[&quot;x&quot;][1] or more general self.atomic_props[&quot;x&quot;][node]</span>
<span class="sd">        Ich glaube das haelt auf jeden Fall fuer alle selber erzeugten Graphen</span>
<span class="sd">        den Dummen Testparamater muss ich mitschleppen, um das gegen meine alte, ultra behinderte Grapherstellung testen</span>
<span class="sd">        zu koennen</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ligands&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ligands</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">inherit_global_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_input_inherit_global_properties</span><span class="p">(</span><span class="n">inherit_global_properties</span><span class="p">)</span>

        <span class="n">atoms</span><span class="p">,</span> <span class="n">idc</span> <span class="o">=</span> <span class="n">get_sorted_atoms_and_indices_from_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;atoms&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">:</span>
            <span class="c1"># if not atoms == self.atomic_props[&#39;atoms&#39;]:</span>
            <span class="c1">#     breakpoint()</span>

            <span class="k">assert</span> <span class="n">atoms</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">],</span> <span class="s1">&#39;Order of atoms in graph and in atomic_props doesn</span><span class="se">\&#39;</span><span class="s1">t match.&#39;</span>

        <span class="c1"># first we gather some information around the metal in the initial graph</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">metal_in_complex</span> <span class="o">=</span> <span class="n">identify_metal_in_ase_mol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">metal_node</span> <span class="o">=</span> <span class="n">find_node_in_graph_by_label</span><span class="p">(</span><span class="n">G</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">label_to_find</span><span class="o">=</span><span class="n">metal_in_complex</span><span class="p">,</span> <span class="n">expected_hits</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">metal_neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">metal_node</span><span class="p">))</span>  <span class="c1"># all neighbor nodes of the metal</span>
        <span class="n">metal_neighbor_elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_label&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">metal_neighbors</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idc</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
            <span class="c1">#graph.nodes[i][&#39;orig_idx&#39;] = i</span>
            <span class="c1">#graph.nodes[i][&#39;metal_neighbor&#39;] = i in metal_neighbors</span>
            <span class="k">assert</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_label&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">el</span><span class="p">,</span> <span class="s1">&#39;atom and index don</span><span class="se">\&#39;</span><span class="s1">t match.&#39;</span>

        <span class="c1"># next we create the ripped graph</span>
        <span class="n">ripped_graph</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">ripped_graph</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">metal_node</span><span class="p">)</span>

        <span class="n">conn_components</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span>
                           <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">ripped_graph</span><span class="p">)]</span>  <span class="c1"># sorting of components very important</span>
        <span class="n">conn_components</span> <span class="o">=</span> <span class="p">[</span><span class="n">comp</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span>
                           <span class="nb">sorted</span><span class="p">(</span><span class="n">conn_components</span><span class="p">,</span>
                                  <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)]</span>  <span class="c1"># important: sort by string of list, makes order of ligands unique</span>

        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">conn_components</span><span class="p">:</span>
            <span class="c1"># if this set is empty, the ligand has no connection to the metal</span>
            <span class="n">functional_atom_indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">component</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">metal_neighbors</span><span class="p">))))</span>
            <span class="k">assert</span> <span class="nb">max</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">ripped_graph</span><span class="p">),</span> <span class="s1">&#39;Indices dont make sense. Most likely this is an implementation error where due to the deletion of the metal atom the indices of original and ripped graph dont match.&#39;</span>

            <span class="n">denticity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">functional_atom_indices</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">denticity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># because in the assembly 0 is the placeholder for the reactant, whereas -1 means this is just a remainder in the .xyz, not</span>
                <span class="c1"># connected to the metal at all</span>
                <span class="n">denticity</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># with that it is insanely easy to determine the atomic properties of the ligand</span>
            <span class="k">assert</span> <span class="n">component</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">component</span><span class="p">),</span> <span class="s1">&#39;The list of ligand indices is not sorted, but that is assumed in many parts of this project.&#39;</span>
            <span class="n">ligand_atomic_props</span> <span class="o">=</span> <span class="p">{</span><span class="n">key_</span><span class="p">:</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">item_</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">component</span><span class="p">]</span> <span class="k">for</span> <span class="n">key_</span><span class="p">,</span> <span class="n">item_</span> <span class="ow">in</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">atomic_props</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">ligand_atomic_props</span><span class="p">[</span><span class="s1">&#39;original_complex_indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">component</span>

            <span class="n">ligand_graph</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">ripped_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">component</span><span class="p">))</span>
            <span class="n">atoms_lig</span><span class="p">,</span> <span class="n">idc_lig</span> <span class="o">=</span> <span class="n">get_sorted_atoms_and_indices_from_graph</span><span class="p">(</span><span class="n">ligand_graph</span><span class="p">)</span>

            <span class="c1"># problem: the functional_atom_indices are the indices in the full original metal, rather than the ligand only</span>
            <span class="c1"># so we have to convert them to the index in the ligand_atomic_props</span>
            <span class="n">local_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">component</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">functional_atom_indices</span><span class="p">]</span>
            <span class="n">local_elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">ligand_atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">local_indices</span><span class="p">]</span>

            <span class="c1"># Doublechecking</span>
            <span class="k">if</span> <span class="n">local_indices</span> <span class="o">!=</span> <span class="p">[]:</span>  <span class="c1"># otherwise error for unconnected ligands</span>
                <span class="k">assert</span> <span class="nb">max</span><span class="p">(</span><span class="n">local_indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">ligand_graph</span><span class="p">),</span> <span class="s1">&#39;local_indices make no sense, an index is greater than the number of elements.&#39;</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">el</span> <span class="ow">in</span> <span class="n">metal_neighbor_elements</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">local_elements</span><span class="p">),</span> <span class="s1">&#39;Inconsistent elements of the metal neighbors.&#39;</span>
            <span class="k">assert</span> <span class="n">local_indices</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">local_indices</span><span class="p">),</span> <span class="s1">&#39;local_indices is not sorted but should be.&#39;</span>
            <span class="k">assert</span> <span class="n">atoms_lig</span> <span class="o">==</span> <span class="n">ligand_atomic_props</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">],</span> <span class="s1">&#39;elements of graph and atomic_props not consistent&#39;</span>
            <span class="k">assert</span> <span class="p">[</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">component</span><span class="p">]</span> <span class="o">==</span> <span class="n">ligand_atomic_props</span><span class="p">[</span>
                <span class="s1">&#39;atoms&#39;</span><span class="p">],</span> <span class="s1">&#39;ligand atoms not consistent with original complex atoms.&#39;</span>

            <span class="n">ligand_name</span><span class="p">,</span> <span class="n">csd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligand_naming</span><span class="p">(</span><span class="n">denticity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligands</span><span class="p">)</span>

            <span class="n">ligand_global_props</span> <span class="o">=</span> <span class="p">{</span><span class="n">prop</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">[</span><span class="n">prop</span><span class="p">]</span> <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">inherit_global_properties</span><span class="p">}</span>
            <span class="n">new_lig</span> <span class="o">=</span> <span class="n">RCA_Ligand</span><span class="p">(</span><span class="n">denticity</span><span class="o">=</span><span class="n">denticity</span><span class="p">,</span>
                                 <span class="n">ligand_to_metal</span><span class="o">=</span><span class="n">local_indices</span><span class="p">,</span>
                                 <span class="n">atomic_props</span><span class="o">=</span><span class="n">ligand_atomic_props</span><span class="p">,</span>
                                 <span class="n">name</span><span class="o">=</span><span class="n">ligand_name</span><span class="p">,</span>
                                 <span class="n">graph</span><span class="o">=</span><span class="n">ligand_graph</span><span class="p">,</span>
                                 <span class="n">global_props</span><span class="o">=</span><span class="n">ligand_global_props</span><span class="p">,</span>
                                 <span class="n">original_metal</span><span class="o">=</span><span class="n">DART_Element</span><span class="p">(</span><span class="n">metal_in_complex</span><span class="p">)</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">,</span>
                                 <span class="n">original_metal_position</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_position</span><span class="p">,</span>
                                 <span class="n">original_metal_os</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_oxi_state</span>
                                 <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">ligands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_lig</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligands</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;WARNING: Complex </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">global_props</span><span class="p">[</span><span class="s2">&quot;CSD_code&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> has no ligands extracted.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_smiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">only_core_complex</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">full_smiles</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_smiles</span><span class="p">()</span>
        <span class="n">smiles</span> <span class="o">=</span> <span class="n">full_smiles</span>
        <span class="k">if</span> <span class="n">only_core_complex</span><span class="p">:</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">sm</span> <span class="k">for</span> <span class="n">sm</span> <span class="ow">in</span> <span class="n">smiles</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metal</span> <span class="ow">in</span> <span class="n">sm</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;There should be exactly one SMILES string containing the metal.&#39;</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">smiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Assert</span>
        <span class="n">smiles_graph</span> <span class="o">=</span> <span class="n">pysmiles</span><span class="o">.</span><span class="n">read_smiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">explicit_hydrogen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">smiles_hash</span> <span class="o">=</span> <span class="n">get_graph_hash</span><span class="p">(</span><span class="n">smiles_graph</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="s1">&#39;element&#39;</span><span class="p">)</span>
        <span class="n">core_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_only_complex_graph_connected_to_metal</span><span class="p">()</span>
        <span class="n">core_graph_hash</span> <span class="o">=</span> <span class="n">get_graph_hash</span><span class="p">(</span><span class="n">core_graph</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">smiles_hash</span> <span class="o">==</span> <span class="n">core_graph_hash</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">core_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">9999999999</span><span class="p">:</span>
            <span class="n">view_graph</span><span class="p">(</span><span class="n">core_graph</span><span class="p">,</span> <span class="n">save_path</span><span class="o">=</span><span class="s1">&#39;/Users/timosommer/Downloads/core_graph.png&#39;</span><span class="p">)</span>
            <span class="n">view_graph</span><span class="p">(</span><span class="n">smiles_graph</span><span class="p">,</span> <span class="n">save_path</span><span class="o">=</span><span class="s1">&#39;/Users/timosommer/Downloads/smiles_graph.png&#39;</span><span class="p">,</span> <span class="n">node_label</span><span class="o">=</span><span class="s1">&#39;element&#39;</span><span class="p">)</span>

            <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># assert smiles_hash == core_graph_hash, &#39;SMILES and graph hash do not match.&#39;</span>

        <span class="k">return</span> <span class="n">smiles</span>

    <span class="k">def</span> <span class="nf">generate_descriptors_of_complex_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">only_core_complex</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">xtb</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates descriptors for the complex and its ligands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">src11_machine_learning.utils.utilities_ML</span> <span class="kn">import</span> <span class="n">get_element_descriptors</span>
        <span class="kn">from</span> <span class="nn">src11_machine_learning.dataset_preparation.descriptors</span> <span class="kn">import</span> <span class="n">RAC</span>
        <span class="n">descriptors</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Complex descriptors</span>
        <span class="n">descriptors</span><span class="p">[</span><span class="s1">&#39;n_ligands&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">lig</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligands</span> <span class="k">if</span> <span class="n">lig</span><span class="o">.</span><span class="n">denticity</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">only_core_complex</span><span class="p">)</span>

        <span class="c1"># Metal center descriptors</span>
        <span class="n">metal_descriptors</span> <span class="o">=</span> <span class="n">get_element_descriptors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metal</span><span class="p">)</span>
        <span class="n">metal_descriptors</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;metal_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">metal_descriptors</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">descriptors</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">metal_descriptors</span><span class="p">)</span>

        <span class="c1"># Coordinating_atom descriptors</span>
        <span class="n">coords_descriptors</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_element_descriptors</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">donor_elements</span><span class="p">]</span>
        <span class="n">coords_descriptors</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">coords_descriptors</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">coords_descriptors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">coords_descriptors</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;coord_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">coords_descriptors</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">descriptors</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">coords_descriptors</span><span class="p">)</span>

        <span class="c1"># Graph descriptors</span>
        <span class="c1"># RDKit descriptors</span>
        <span class="c1"># smiles = self.get_smiles(only_core_complex=only_core_complex)</span>
        <span class="c1"># rdkit_descriptors = RDKit_2D([smiles]).compute_2Drdkit().to_dict(orient=&#39;records&#39;)[0]</span>
        <span class="c1"># descriptors.update(rdkit_descriptors)</span>
        <span class="c1"># Own RAC descriptors</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_only_complex_graph_connected_to_metal</span><span class="p">()</span> <span class="k">if</span> <span class="n">only_core_complex</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
        <span class="n">graph_descriptors</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">RAC</span><span class="p">()</span><span class="o">.</span><span class="n">molecule_autocorrelation</span><span class="p">(</span><span class="n">mol</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">return_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">graph_descriptors</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;own_graph_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">graph_descriptors</span><span class="p">)}</span>
        <span class="n">descriptors</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">graph_descriptors</span><span class="p">)</span>


        <span class="c1"># XTB descriptors of ligands</span>
        <span class="k">if</span> <span class="n">xtb</span><span class="p">:</span>
            <span class="n">xtb_descriptors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">lig</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligands</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lig</span><span class="o">.</span><span class="n">denticity</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">only_core_complex</span><span class="p">:</span>
                    <span class="n">xtb_descriptors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lig</span><span class="o">.</span><span class="n">get_xtb_descriptors</span><span class="p">())</span>


        <span class="k">return</span> <span class="n">descriptors</span>








    <span class="k">def</span> <span class="nf">write_to_mol_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_graph_dict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_ligands</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Manually initialize special fields</span>
        <span class="k">if</span> <span class="n">include_graph_dict</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;graph_dict&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph_to_dict_with_node_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ligands&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">lig</span><span class="o">.</span><span class="n">write_to_mol_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">lig</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ligands</span><span class="p">]</span>

        <span class="c1"># Do not output write these fields to the output dictionary, mostly because they are not json serializable</span>
        <span class="n">do_not_output_automatically</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ligands&#39;</span><span class="p">,</span> <span class="s1">&#39;node_label&#39;</span><span class="p">,</span> <span class="s1">&#39;mol&#39;</span><span class="p">,</span> <span class="s1">&#39;smiles&#39;</span><span class="p">,</span> <span class="s1">&#39;rdkit_mol&#39;</span><span class="p">,</span> <span class="s1">&#39;graph&#39;</span><span class="p">,</span> <span class="s1">&#39;coordinates&#39;</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">,</span> <span class="s1">&#39;csd_code&#39;</span><span class="p">,</span> <span class="s1">&#39;graph_with_metal&#39;</span><span class="p">,</span> <span class="s1">&#39;atomic_index_to_graph_index&#39;</span><span class="p">,</span> <span class="s1">&#39;graph_index_to_atomic_index&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">prop</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">do_not_output_automatically</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">prop</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_mol_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dict_</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the ligand from a provided dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">necessary_props</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;atomic_props&quot;</span><span class="p">,</span> <span class="s2">&quot;global_props&quot;</span><span class="p">,</span> <span class="s2">&quot;graph_dict&quot;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">necessary_props</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dict_</span><span class="o">.</span><span class="n">keys</span><span class="p">())),</span> <span class="sa">f</span><span class="s1">&#39;Any of the necessary keys </span><span class="si">{</span><span class="n">necessary_props</span><span class="si">}</span><span class="s1"> is not present.&#39;</span>

        <span class="k">if</span> <span class="s1">&#39;ligands&#39;</span> <span class="ow">in</span> <span class="n">dict_</span><span class="p">:</span>
            <span class="n">dict_</span><span class="p">[</span><span class="s1">&#39;ligands&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">RCA_Ligand</span><span class="o">.</span><span class="n">read_from_mol_dict</span><span class="p">(</span><span class="n">lig</span><span class="p">)</span> <span class="k">for</span> <span class="n">lig</span> <span class="ow">in</span> <span class="n">dict_</span><span class="p">[</span><span class="s1">&#39;ligands&#39;</span><span class="p">]]</span>
            <span class="c1"># This sounds stupid but this is because otherwise the RCA_molecule class sets up self.ligands = [] which then collides when the actual ligands which are read in here are added because for safety the code checks that it doesn&#39;t overwrite anything.</span>
            <span class="n">has_ligands</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">has_ligands</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="s1">&#39;total_q&#39;</span> <span class="ow">in</span> <span class="n">dict_</span><span class="p">:</span>
            <span class="n">dict_</span><span class="p">[</span><span class="s1">&#39;charge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_</span><span class="p">[</span><span class="s1">&#39;total_q&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">dict_</span><span class="p">[</span><span class="s1">&#39;total_q&#39;</span><span class="p">]</span>

        <span class="n">other_props</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dict_</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">necessary_props</span><span class="p">}</span>

        <span class="c1"># Optionally add graph if it is present in the dictionary</span>
        <span class="k">if</span> <span class="s1">&#39;graph_dict&#39;</span> <span class="ow">in</span> <span class="n">dict_</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dict_</span><span class="p">[</span><span class="s1">&#39;graph_dict&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">graph_from_graph_dict</span><span class="p">(</span><span class="n">dict_</span><span class="p">[</span><span class="s1">&#39;graph_dict&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">atomic_props</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;atomic_props&quot;</span><span class="p">],</span>
            <span class="n">global_props</span><span class="o">=</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;global_props&quot;</span><span class="p">],</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">has_ligands</span><span class="o">=</span><span class="n">has_ligands</span><span class="p">,</span>
            <span class="n">other_props</span><span class="o">=</span><span class="n">other_props</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>





</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">DART</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Timo Sommer, Cian Clarke.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.0.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>